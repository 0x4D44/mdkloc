    1|       |//! Source Code Analysis Tool
    2|       |//!
    3|       |//! This tool performs comprehensive analysis of source code across multiple programming languages,
    4|       |//! providing detailed statistics about code, comment, and blank line distribution.
    5|       |//!
    6|       |//! Supported languages: Rust, Go, Python, Java, C/C++, C#, JavaScript, TypeScript,
    7|       |//! PHP, Perl, Ruby, Shell, Pascal, Scala, YAML, XML, JSON, HTML, TOML,
    8|       |//! Makefile, Dockerfile, INI, HCL, CMake, PowerShell, Batch, TCL,
    9|       |//! ReStructuredText, Velocity, Mustache, Protobuf, SVG, XSL,
   10|       |//! Algol, COBOL, Fortran, Assembly, DCL, IPLAN.
   11|       |
   12|       |use clap::{ArgAction, Parser};
   13|       |use std::collections::HashMap;
   14|       |use std::env;
   15|       |use std::fs;
   16|       |use std::io::{self, BufRead, BufReader, Write};
   17|       |use std::path::{Path, PathBuf};
   18|       |
   19|       |use colored::*;
   20|       |use glob::Pattern;
   21|       |use std::sync::atomic::{AtomicU64, Ordering};
   22|       |use std::sync::Arc;
   23|       |use std::time::{Duration, Instant};
   24|       |
   25|       |// Fixed width for the directory column.
   26|       |const DIR_WIDTH: usize = 40;
   27|       |const LANG_WIDTH: usize = 16;
   28|       |
   29|       |// Performance metrics structure
   30|       |struct PerformanceMetrics {
   31|       |    files_processed: Arc<AtomicU64>,
   32|       |    lines_processed: Arc<AtomicU64>,
   33|       |    start_time: Instant,
   34|       |    last_update: Instant,
   35|       |    writer: Box<dyn Write + Send>,
   36|       |    progress_enabled: bool,
   37|       |}
   38|       |
   39|       |#[derive(Parser, Debug)]
   40|       |#[command(
   41|       |    author,
   42|       |    version,
   43|       |    about = "Source code analyser for multiple programming languages",
   44|       |    long_about = "Supported languages: Rust, Go, Python, Java, C/C++, C#, JavaScript, TypeScript, PHP, Perl, Ruby, Shell, Pascal, Scala, YAML, XML, JSON, HTML, TOML, Makefile, Dockerfile, INI, HCL, CMake, PowerShell, Batch, TCL, ReStructuredText, Velocity, Mustache, Protobuf, SVG, XSL, Algol, COBOL, Fortran, Assembly, DCL, IPLAN.",
   45|       |    color = clap::ColorChoice::Always
   46|       |)]
   47|       |struct Args {
   48|       |    #[arg(default_value = ".")]
   49|      0|    path: String,
   50|       |
   51|       |    #[arg(short, long, action = ArgAction::Append)]
   52|      1|    ignore: Vec<String>,
   53|       |
   54|       |    #[arg(short, long)]
   55|      0|    verbose: bool,
   56|       |
   57|       |    #[arg(short, long, default_value = "1000000")]
   58|      0|    max_entries: usize,
   59|       |
   60|       |    #[arg(short = 'd', long, default_value = "100")]
   61|      0|    max_depth: usize,
   62|       |
   63|       |    #[arg(short = 'n', long)]
   64|      0|    non_recursive: bool,
   65|       |
   66|       |    #[arg(short = 'f', long)]
   67|       |    filespec: Option<String>,
   68|       |}
   69|       |
   70|       |#[derive(Debug, Default, Clone, Copy)]
   71|       |struct LanguageStats {
   72|       |    code_lines: u64,
   73|       |    comment_lines: u64,
   74|       |    blank_lines: u64,
   75|       |    overlap_lines: u64,
   76|       |}
   77|       |
   78|       |#[derive(Debug, Default)]
   79|       |struct DirectoryStats {
   80|       |    language_stats: HashMap<String, (u64, LanguageStats)>, // (file_count, stats) per language
   81|       |}
   82|       |
   83|     19|fn normalize_stats(mut stats: LanguageStats, total_lines: u64) -> LanguageStats {
   84|     19|    if total_lines == 0 {
   85|      1|        return stats;
   86|     18|    }
   87|     18|    let sum = stats.code_lines + stats.comment_lines + stats.blank_lines;
   88|     18|    if sum > total_lines {
   89|      1|        let mut overlap = sum - total_lines;
   90|      1|        if stats.blank_lines > 0 {
   91|      0|            let blank_reduce = stats.blank_lines.min(overlap);
   92|      0|            stats.blank_lines -= blank_reduce;
   93|      0|            overlap -= blank_reduce;
   94|      1|        }
   95|      1|        stats.overlap_lines = overlap;
   96|     17|    } else if sum < total_lines && sum > 0 {
                                                 ^2
   97|      0|        stats.blank_lines += total_lines - sum;
   98|      0|        stats.overlap_lines = 0;
   99|     17|    } else {
  100|     17|        stats.overlap_lines = 0;
  101|     17|    }
  102|     18|    stats
  103|     19|}
  104|       |
  105|       |impl PerformanceMetrics {
  106|      3|    fn new() -> Self {
  107|      3|        PerformanceMetrics::with_writer(Box::new(io::stdout()), true)
  108|      3|    }
  109|       |
  110|     15|    fn with_writer(writer: Box<dyn Write + Send>, progress_enabled: bool) -> Self {
  111|     15|        PerformanceMetrics {
  112|     15|            files_processed: Arc::new(AtomicU64::new(0)),
  113|     15|            lines_processed: Arc::new(AtomicU64::new(0)),
  114|     15|            start_time: Instant::now(),
  115|     15|            last_update: Instant::now(),
  116|     15|            writer,
  117|     15|            progress_enabled,
  118|     15|        }
  119|     15|    }
  120|       |
  121|     17|    fn update(&mut self, new_lines: u64) {
  122|     17|        self.files_processed.fetch_add(1, Ordering::Relaxed);
  123|     17|        self.lines_processed.fetch_add(new_lines, Ordering::Relaxed);
  124|     17|
  125|     17|        // Update progress every second
  126|     17|        let now = Instant::now();
  127|     17|        if now.duration_since(self.last_update) >= Duration::from_secs(1) {
  128|      1|            self.print_progress();
  129|      1|            self.last_update = now;
  130|     16|        }
  131|     17|    }
  132|       |
  133|      1|    fn print_progress(&mut self) {
  134|      1|        if !self.progress_enabled {
  135|      0|            return;
  136|      1|        }
  137|      1|
  138|      1|        let elapsed = self.start_time.elapsed().as_secs_f64();
  139|      1|        let files = self.files_processed.load(Ordering::Relaxed);
  140|      1|        let lines = self.lines_processed.load(Ordering::Relaxed);
  141|      1|
  142|      1|        let writer = &mut self.writer;
  143|      1|        let _ = write!(
  144|      1|            writer,
  145|      1|            "\rProcessed {} files ({:.1} files/sec) and {} lines ({:.1} lines/sec)...",
  146|      1|            files,
  147|      1|            files as f64 / elapsed,
  148|      1|            lines,
  149|      1|            lines as f64 / elapsed
  150|      1|        );
  151|      1|        let _ = writer.flush();
  152|      1|    }
  153|       |
  154|      3|    fn print_final_stats(&mut self) {
  155|      3|        let elapsed = self.start_time.elapsed().as_secs_f64();
  156|      3|        let files = self.files_processed.load(Ordering::Relaxed);
  157|      3|        let lines = self.lines_processed.load(Ordering::Relaxed);
  158|      3|
  159|      3|        let writer = &mut self.writer;
  160|      3|        let _ = writeln!(writer, "\n\n{}", "Performance Summary:".blue().bold());
  161|      3|        let _ = writeln!(
  162|      3|            writer,
  163|      3|            "Total time: {} seconds",
  164|      3|            format!("{:.2}", elapsed).bright_yellow()
  165|      3|        );
  166|      3|        let _ = writeln!(
  167|      3|            writer,
  168|      3|            "Files processed: {} ({})",
  169|      3|            files.to_string().bright_yellow(),
  170|      3|            format!("{:.1} files/sec", safe_rate(files, elapsed)).bright_yellow()
  171|      3|        );
  172|      3|        let _ = writeln!(
  173|      3|            writer,
  174|      3|            "Lines processed: {} ({})",
  175|      3|            lines.to_string().bright_yellow(),
  176|      3|            format!("{:.1} lines/sec", safe_rate(lines, elapsed)).bright_yellow()
  177|      3|        );
  178|      3|    }
  179|       |}
  180|       |
  181|       |/// Reads a file’s entire content as lines, converting invalid UTF‑8 sequences using replacement characters.
  182|       |struct LossyLineReader {
  183|       |    reader: BufReader<fs::File>,
  184|       |    buffer: Vec<u8>,
  185|       |}
  186|       |
  187|       |impl LossyLineReader {
  188|     86|    fn new(file: fs::File) -> Self {
  189|     86|        Self {
  190|     86|            reader: BufReader::new(file),
  191|     86|            buffer: Vec::with_capacity(8 * 1024),
  192|     86|        }
  193|     86|    }
  194|       |}
  195|       |
  196|       |impl Iterator for LossyLineReader {
  197|       |    type Item = io::Result<String>;
  198|       |
  199|    355|    fn next(&mut self) -> Option<Self::Item> {
  200|    355|        self.buffer.clear();
  201|    355|        match self.reader.read_until(b'\n', &mut self.buffer) {
  202|     86|            Ok(0) => None,
  203|       |            Ok(_) => {
  204|    269|                let text = String::from_utf8_lossy(&self.buffer);
  205|    269|                let line = text.trim_end_matches(['\n', '\r']).to_string();
  206|    269|                Some(Ok(line))
  207|       |            }
  208|      0|            Err(err) => Some(Err(err)),
  209|       |        }
  210|    355|    }
  211|       |}
  212|       |
  213|       |/// Returns an iterator over the lines of a file, replacing invalid UTF-8 bytes with the replacement character.
  214|     86|fn read_file_lines_lossy(file_path: &Path) -> io::Result<LossyLineReader> {
  215|     86|    let file = fs::File::open(file_path)?;
                                                      ^0
  216|     86|    Ok(LossyLineReader::new(file))
  217|     86|}
  218|       |
  219|       |/// Identify the language based on filename and/or extension (case-insensitive).
  220|       |/// Returns a static string to avoid allocations; callers can `.to_string()` when needed.
  221|     29|fn get_language_from_extension(file_name: &str) -> Option<&'static str> {
  222|     29|    let lower = file_name.to_lowercase();
  223|     29|    // Special filenames without extensions
  224|     29|    if lower.starts_with("dockerfile") {
  225|      1|        return Some("Dockerfile");
  226|     28|    }
  227|     28|    if lower == "makefile" || lower == "gnumakefile" || lower == "bsdmakefile" {
                                                                      ^27
  228|      1|        return Some("Makefile");
  229|     27|    }
  230|     27|    if lower == "cmakelists.txt" {
  231|      1|        return Some("CMake");
  232|     26|    }
  233|     26|    // Common shell dotfiles
  234|     26|    match lower.as_str() {
  235|     26|        ".bashrc" | ".bash_profile" | ".profile" | ".zshrc" | ".zprofile" | ".zshenv"
                                  ^24               ^24          ^24        ^23           ^22
  236|     22|        | ".kshrc" | ".cshrc" => {
  237|      4|            return Some("Shell");
  238|       |        }
  239|     22|        _ => {}
  240|       |    }
  241|       |
  242|       |    // Extract extension if present
  243|     22|    let (_stem, ext) = match file_name.rsplit_once('.') {
  244|     22|        Some((s, e)) if !s.is_empty() => (s, e.to_lowercase()),
  245|      0|        _ => return None,
  246|       |    };
  247|     22|    let ext = ext.as_str();
  248|     22|    match ext {
  249|     22|        // Core set
  250|     22|        "rs" => Some("Rust"),
                              ^15
  251|      7|        "go" => Some("Go"),
                              ^0
  252|      7|        "py" => Some("Python"),
                              ^2
  253|      5|        "java" => Some("Java"),
                                ^0
  254|      5|        "cpp" | "c" | "h" | "hpp" => Some("C/C++"),
                                                   ^0
  255|      5|        "cs" => Some("C#"),
                              ^0
  256|      5|        "js" => Some("JavaScript"),
                              ^1
  257|      4|        "ts" => Some("TypeScript"),
                              ^1
  258|      3|        "jsx" => Some("JSX"),
                               ^0
  259|      3|        "tsx" => Some("TSX"),
                               ^0
  260|      3|        "php" => Some("PHP"),
                               ^0
  261|      3|        "pl" | "pm" | "t" => Some("Perl"),
                                           ^0
  262|      3|        "rb" => Some("Ruby"),
                              ^0
  263|      3|        "sh" => Some("Shell"),
                              ^0
  264|      3|        "pas" => Some("Pascal"),
                               ^0
  265|       |        // Newly supported
  266|      3|        "scala" | "sbt" => Some("Scala"),
                                         ^0
  267|      3|        "yaml" | "yml" => Some("YAML"),
                                        ^0
  268|      3|        "json" => Some("JSON"),
                                ^0
  269|       |        // XML family (SVG/XSL handled separately)
  270|      3|        "xml" | "xsd" => Some("XML"),
                                       ^0
  271|      3|        "html" | "htm" | "xhtml" => Some("HTML"),
                                                  ^0
  272|      3|        "toml" => Some("TOML"),
                                ^0
  273|       |        // Makefile variants
  274|      3|        "mk" | "mak" => Some("Makefile"),
                             ^2       ^1
  275|       |        // INI-like
  276|      2|        "ini" | "cfg" | "conf" | "properties" | "prop" => Some("INI"),
                                                                        ^0
  277|       |        // HCL / Terraform
  278|      2|        "hcl" | "tf" | "tfvars" => Some("HCL"),
                                                 ^0
  279|       |        // CMake modules
  280|      2|        "cmake" => Some("CMake"),
                                 ^0
  281|       |        // PowerShell
  282|      2|        "ps1" | "psm1" | "psd1" => Some("PowerShell"),
                                                 ^0
  283|       |        // Batch / CMD
  284|      2|        "bat" | "cmd" => Some("Batch"),
                                       ^0
  285|       |        // TCL
  286|      2|        "tcl" => Some("TCL"),
                               ^0
  287|       |        // ReStructuredText
  288|      2|        "rst" | "rest" => Some("ReStructuredText"),
                                        ^0
  289|       |        // Velocity templates
  290|      2|        "vm" | "vtl" => Some("Velocity"),
                                      ^0
  291|       |        // Mustache templates
  292|      2|        "mustache" => Some("Mustache"),
                                    ^0
  293|       |        // Protobuf
  294|      2|        "proto" => Some("Protobuf"),
                                 ^0
  295|       |        // SVG / XSL
  296|      2|        "svg" => Some("SVG"),
                               ^0
  297|      2|        "xsl" | "xslt" => Some("XSL"),
                                        ^0
  298|       |        // Algol
  299|      2|        "alg" | "algol" | "a60" | "a68" => Some("Algol"),
                                                         ^0
  300|       |        // COBOL and copybooks
  301|      2|        "cob" | "cbl" | "cobol" | "cpy" => Some("COBOL"),
                                                         ^0
  302|       |        // Fortran (fixed/free forms)
  303|      2|        "f" | "for" | "f77" | "f90" | "f95" | "f03" | "f08" | "f18" => Some("Fortran"),
                                                                                     ^0
  304|       |        // Assembly (x86 et al.)
  305|      2|        "asm" | "s" | "S" => Some("Assembly"),
                                           ^0
  306|       |        // DCL (OpenVMS command procedures)
  307|      2|        "com" => Some("DCL"),
                               ^1
  308|       |        // IPLAN (PSS/E)
  309|      1|        "ipl" => Some("IPLAN"),
                               ^0
  310|      1|        _ => None,
  311|       |    }
  312|     29|}
  313|       |
  314|     17|fn is_ignored_dir(path: &Path) -> bool {
  315|     17|    let dir_name = path.file_name().and_then(|n| n.to_str()).unwrap_or("");
  316|     17|    let ignored = [
  317|     17|        "target",
  318|     17|        "node_modules",
  319|     17|        "build",
  320|     17|        "dist",
  321|     17|        ".git",
  322|     17|        "venv",
  323|     17|        "__pycache__",
  324|     17|        "bin",
  325|     17|        "obj",
  326|     17|    ];
  327|     17|    ignored.contains(&dir_name)
  328|     17|}
  329|       |
  330|       |/// Helper function that truncates the given string to a maximum number of characters by keeping the last characters.
  331|       |/// If truncation occurs, the returned string is prefixed with "..." so that its total length equals max_len.
  332|      4|fn truncate_start(s: &str, max_len: usize) -> String {
  333|      4|    let char_count = s.chars().count();
  334|      4|    if char_count <= max_len {
  335|      1|        s.to_string()
  336|       |    } else {
  337|       |        // More efficient implementation without multiple reverses and unnecessary allocations
  338|       |        // Skip front chars to keep only the last (max_len - 3) chars, then prepend "..."
  339|      3|        let skip_count = char_count - (max_len - 3);
  340|      3|        let truncated: String = s.chars().skip(skip_count).collect();
  341|      3|        format!("...{}", truncated)
  342|       |    }
  343|      4|}
  344|       |
  345|      8|fn safe_rate(value: u64, elapsed_secs: f64) -> f64 {
  346|      8|    if elapsed_secs <= f64::EPSILON {
  347|      1|        0.0
  348|       |    } else {
  349|      7|        value as f64 / elapsed_secs
  350|       |    }
  351|      8|}
  352|       |
  353|     10|fn safe_percentage(numerator: u64, denominator: u64) -> f64 {
  354|     10|    if denominator == 0 {
  355|      1|        0.0
  356|       |    } else {
  357|      9|        (numerator as f64 / denominator as f64) * 100.0
  358|       |    }
  359|     10|}
  360|       |
  361|       |/// Delegate counting to the appropriate parser based on file extension.
  362|     21|fn count_lines_with_stats(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  363|     21|    // Inspect filename for special cases (Dockerfile*, Makefile variants)
  364|     21|    let file_name_lower = file_path
  365|     21|        .file_name()
  366|     21|        .and_then(|n| n.to_str())
  367|     21|        .map(|s| s.to_lowercase())
  368|     21|        .unwrap_or_default();
  369|     21|    if file_name_lower.starts_with("dockerfile") {
  370|      1|        return count_dockerfile_lines(file_path);
  371|     20|    }
  372|     20|    if file_name_lower == "makefile"
  373|     19|        || file_name_lower == "gnumakefile"
  374|     19|        || file_name_lower == "bsdmakefile"
  375|       |    {
  376|      1|        return count_makefile_lines(file_path);
  377|     19|    }
  378|     19|    if file_name_lower == "cmakelists.txt" {
  379|      1|        return count_cmake_lines(file_path);
  380|     18|    }
  381|     18|    // Get extension in lowercase for case-insensitive matching.
  382|     18|    let extension = file_path
  383|     18|        .extension()
  384|     18|        .and_then(|ext| ext.to_str())
  385|     18|        .unwrap_or("")
  386|     18|        .to_lowercase();
  387|     18|    match extension.as_str() {
  388|     18|        "rs" => count_rust_lines(file_path),
                              ^15
  389|      3|        "go" => count_c_style_lines(file_path),
                              ^0
  390|      3|        "py" => count_python_lines(file_path),
                              ^1
  391|      2|        "java" | "c" | "cpp" | "h" | "hpp" | "cs" => count_c_style_lines(file_path),
                                                                   ^0
  392|      2|        "js" | "ts" | "jsx" | "tsx" => count_javascript_lines(file_path),
                                                     ^0
  393|      2|        "php" => count_php_lines(file_path),
                               ^0
  394|      2|        "pl" | "pm" | "t" => count_perl_lines(file_path),
                                           ^0
  395|      2|        "rb" => count_ruby_lines(file_path),
                              ^0
  396|      2|        "sh" => count_shell_lines(file_path),
                              ^0
  397|      2|        "pas" => count_pascal_lines(file_path),
                               ^0
  398|       |        // Newly supported languages
  399|      2|        "scala" | "sbt" => count_c_style_lines(file_path),
                                         ^0
  400|      2|        "yaml" | "yml" => count_yaml_lines(file_path),
                                        ^0
  401|      2|        "json" => count_json_lines(file_path),
                                ^0
  402|      2|        "xml" | "xsd" => count_xml_like_lines(file_path),
                                       ^0
  403|      2|        "html" | "htm" | "xhtml" => count_xml_like_lines(file_path),
                                                  ^0
  404|      2|        "toml" => count_toml_lines(file_path),
                                ^0
  405|      2|        "mk" | "mak" => count_makefile_lines(file_path),
                                      ^0
  406|      2|        "ini" | "cfg" | "conf" | "properties" | "prop" => count_ini_lines(file_path),
                                                                        ^0
  407|      2|        "hcl" | "tf" | "tfvars" => count_hcl_lines(file_path),
                                                 ^0
  408|      2|        "cmake" => count_cmake_lines(file_path),
                                 ^0
  409|      2|        "ps1" | "psm1" | "psd1" => count_powershell_lines(file_path),
                                                 ^0
  410|      2|        "bat" | "cmd" => count_batch_lines(file_path),
                                       ^0
  411|      2|        "tcl" => count_tcl_lines(file_path),
                               ^0
  412|      2|        "rst" | "rest" => count_rst_lines(file_path),
                                        ^0
  413|      2|        "vm" | "vtl" => count_velocity_lines(file_path),
                                      ^0
  414|      2|        "mustache" => count_mustache_lines(file_path),
                                    ^0
  415|      2|        "proto" => count_c_style_lines(file_path),
                                 ^0
  416|      2|        "svg" => count_xml_like_lines(file_path),
                               ^0
  417|      2|        "xsl" | "xslt" => count_xml_like_lines(file_path),
                                        ^0
  418|       |        // New classic languages
  419|      2|        "alg" | "algol" | "a60" | "a68" => count_algol_lines(file_path),
                                                         ^0
  420|      2|        "cob" | "cbl" | "cobol" | "cpy" => count_cobol_lines(file_path),
                                                         ^0
  421|      2|        "f" | "for" | "f77" | "f90" | "f95" | "f03" | "f08" | "f18" => {
  422|      0|            count_fortran_lines(file_path)
  423|       |        }
  424|      2|        "asm" | "s" => count_asm_lines(file_path),
                                     ^0
  425|      2|        "com" => count_dcl_lines(file_path),
                               ^1
  426|      1|        "ipl" => count_iplan_lines(file_path),
                               ^0
  427|      1|        _ => count_generic_lines(file_path),
  428|       |    }
  429|     21|}
  430|       |
  431|      2|fn count_generic_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  432|      2|    let mut stats = LanguageStats::default();
  433|      2|    let mut total_lines = 0;
  434|      6|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
  435|      6|        let line = line_result?;
                                            ^0
  436|      6|        total_lines += 1;
  437|      6|        if line.trim().is_empty() {
  438|      2|            stats.blank_lines += 1;
  439|      4|        } else {
  440|      4|            stats.code_lines += 1;
  441|      4|        }
  442|       |    }
  443|      2|    Ok((stats, total_lines))
  444|      2|}
  445|       |
  446|     17|fn count_rust_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  447|     17|    let mut stats = LanguageStats::default();
  448|     17|    let mut in_block_comment = false;
  449|     17|    let mut total_lines = 0;
  450|     34|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^17                             ^0
  451|     34|        let line = line_result?;
                                            ^0
  452|     34|        total_lines += 1;
  453|     34|        let trimmed = line.trim();
  454|     34|        if trimmed.is_empty() {
  455|      0|            stats.blank_lines += 1;
  456|      0|            continue;
  457|     34|        }
  458|     34|        if in_block_comment {
  459|      0|            stats.comment_lines += 1;
  460|      0|            if trimmed.contains("*/") {
  461|      0|                in_block_comment = false;
  462|      0|                if let Some(after_comment) = trimmed.split("*/").nth(1) {
  463|      0|                    if !after_comment.trim().is_empty() && !after_comment.trim().starts_with("//") {
  464|      0|                        stats.code_lines += 1;
  465|      0|                    }
  466|      0|                }
  467|      0|            }
  468|      0|            continue;
  469|     34|        }
  470|     34|        if trimmed.starts_with("#[") {
  471|      0|            stats.code_lines += 1;
  472|      0|            continue;
  473|     34|        }
  474|     34|        if trimmed.contains("/*") {
  475|      5|            stats.comment_lines += 1;
  476|      5|            if let Some(before_comment) = trimmed.split("/*").next() {
  477|      5|                if !before_comment.trim().is_empty() {
  478|      1|                    stats.code_lines += 1;
  479|      4|                }
  480|      0|            }
  481|      5|            if !trimmed.contains("*/") {
  482|      0|                in_block_comment = true;
  483|      5|            } else if let Some(after_comment) = trimmed.split("*/").nth(1) {
  484|      5|                if !after_comment.trim().is_empty() && !after_comment.trim().starts_with("//") {
                                                                     ^1
  485|      1|                    stats.code_lines += 1;
  486|      4|                }
  487|      0|            }
  488|      5|            continue;
  489|     29|        }
  490|     29|        if trimmed.starts_with("///") || trimmed.starts_with("//!") || trimmed.starts_with("//") {
                                                       ^28                           ^27
  491|      6|            stats.comment_lines += 1;
  492|      6|            continue;
  493|     23|        }
  494|     23|        stats.code_lines += 1;
  495|       |    }
  496|     17|    Ok((stats, total_lines))
  497|     17|}
  498|       |
  499|      4|fn count_python_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  500|      4|    let mut stats = LanguageStats::default();
  501|      4|    let mut in_multiline_string = false;
  502|      4|    let mut multiline_quote_char = '"';
  503|      4|    let mut prev_line_continued = false;
  504|      4|    let mut total_lines = 0;
  505|     17|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^4                              ^0
  506|     17|        let line = line_result?;
                                            ^0
  507|     17|        total_lines += 1;
  508|     17|        let trimmed = line.trim();
  509|     17|        if trimmed.is_empty() {
  510|      2|            stats.blank_lines += 1;
  511|      2|            continue;
  512|     15|        }
  513|     15|        if in_multiline_string {
  514|      2|            stats.comment_lines += 1;
  515|      2|            let quote = multiline_quote_char.to_string().repeat(3);
  516|      2|            if trimmed.contains(&quote) {
  517|      2|                in_multiline_string = false;
  518|      2|                if let Some(code) = trimmed.split(&quote).nth(1) {
  519|      2|                    if !code.trim().is_empty() && !code.trim_start().starts_with("#") {
                                                                ^0
  520|      0|                        stats.code_lines += 1;
  521|      2|                    }
  522|      0|                }
  523|      0|            }
  524|      2|            continue;
  525|     13|        }
  526|     13|        if trimmed.starts_with("#") {
  527|      2|            stats.comment_lines += 1;
  528|      2|            continue;
  529|     11|        }
  530|     11|        if (trimmed.starts_with("'''") || trimmed.starts_with("\"\"\"")) && !prev_line_continued {
                                                        ^9                                ^4
  531|      3|            let quote = &trimmed[..3];
  532|      3|            if trimmed.len() >= 6 && trimmed[3..].contains(quote) {
  533|      1|                stats.comment_lines += 1;
  534|      1|                if let Some(code) = trimmed.split(quote).nth(2) {
  535|      1|                    if !code.trim().is_empty() && !code.trim_start().starts_with("#") {
  536|      0|                        stats.code_lines += 1;
  537|      1|                    }
  538|      0|                }
  539|      2|            } else {
  540|      2|                in_multiline_string = true;
  541|      2|                multiline_quote_char = quote.chars().next().unwrap();
  542|      2|                stats.comment_lines += 1;
  543|      2|            }
  544|      3|            continue;
  545|      8|        }
  546|      8|        prev_line_continued = trimmed.ends_with('\\');
  547|      8|        stats.code_lines += 1;
  548|       |    }
  549|      4|    Ok((stats, total_lines))
  550|      4|}
  551|       |
  552|      5|fn count_c_style_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  553|      5|    let mut stats = LanguageStats::default();
  554|      5|    let mut in_block_comment = false;
  555|      5|    let mut total_lines = 0;
  556|     14|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^5                              ^0
  557|     14|        let line = line_result?;
                                            ^0
  558|     14|        total_lines += 1;
  559|     14|        let mut s = line.as_str();
  560|     14|        let trimmed_line = s.trim();
  561|     14|        if trimmed_line.is_empty() {
  562|      0|            stats.blank_lines += 1;
  563|      0|            continue;
  564|     14|        }
  565|       |        loop {
  566|     19|            if in_block_comment {
  567|      1|                if let Some(end) = s.find("*/") {
  568|      1|                    stats.comment_lines += 1;
  569|      1|                    s = &s[end + 2..];
  570|      1|                    in_block_comment = false;
  571|      1|                    if s.trim().is_empty() {
  572|      0|                        break;
  573|       |                    } else {
  574|      1|                        continue;
  575|       |                    }
  576|       |                } else {
  577|      0|                    stats.comment_lines += 1;
  578|      0|                    break;
  579|       |                }
  580|       |            } else {
  581|     18|                let p_line = s.find("//");
  582|     18|                let p_block = s.find("/*");
  583|     18|                match (p_line, p_block) {
  584|       |                    (None, None) => {
  585|      7|                        if !s.trim().is_empty() {
  586|      7|                            stats.code_lines += 1;
  587|      7|                        }
                                      ^0
  588|      7|                        break;
  589|       |                    }
  590|      3|                    (Some(pl), None) => {
  591|      3|                        let before = &s[..pl];
  592|      3|                        if !before.trim().is_empty() {
  593|      0|                            stats.code_lines += 1;
  594|      3|                        }
  595|      3|                        stats.comment_lines += 1; // rest of line is comment
  596|      3|                        break;
  597|       |                    }
  598|      6|                    (None, Some(pb)) => {
  599|      6|                        let before = &s[..pb];
  600|      6|                        if !before.trim().is_empty() {
  601|      3|                            stats.code_lines += 1;
  602|      3|                        }
  603|      6|                        stats.comment_lines += 1;
  604|      6|                        s = &s[pb + 2..];
  605|      6|                        if let Some(end) = s.find("*/") {
                                                  ^5
  606|      5|                            s = &s[end + 2..];
  607|      5|                            if s.trim().is_empty() {
  608|      2|                                break;
  609|       |                            } else {
  610|      3|                                continue;
  611|       |                            }
  612|       |                        } else {
  613|      1|                            in_block_comment = true;
  614|      1|                            break;
  615|       |                        }
  616|       |                    }
  617|      2|                    (Some(pl), Some(pb)) => {
  618|      2|                        if pl < pb {
  619|      1|                            let before = &s[..pl];
  620|      1|                            if !before.trim().is_empty() {
  621|      1|                                stats.code_lines += 1;
  622|      1|                            }
                                          ^0
  623|      1|                            stats.comment_lines += 1;
  624|      1|                            break; // rest is comment
  625|       |                        } else {
  626|      1|                            let before = &s[..pb];
  627|      1|                            if !before.trim().is_empty() {
  628|      1|                                stats.code_lines += 1;
  629|      1|                            }
                                          ^0
  630|      1|                            stats.comment_lines += 1;
  631|      1|                            s = &s[pb + 2..];
  632|      1|                            if let Some(end) = s.find("*/") {
  633|      1|                                s = &s[end + 2..];
  634|      1|                                if s.trim().is_empty() {
  635|      0|                                    break;
  636|       |                                } else {
  637|      1|                                    continue;
  638|       |                                }
  639|       |                            } else {
  640|      0|                                in_block_comment = true;
  641|      0|                                break;
  642|       |                            }
  643|       |                        }
  644|       |                    }
  645|       |                }
  646|       |            }
  647|       |        }
  648|       |    }
  649|      5|    Ok((stats, total_lines))
  650|      5|}
  651|       |
  652|      2|fn count_javascript_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  653|      2|    let mut stats = LanguageStats::default();
  654|      2|    let mut in_block_comment = false;
  655|      2|    let mut in_jsx_comment = false;
  656|      2|    let mut total_lines = 0;
  657|     15|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
  658|     15|        let line = line_result?;
                                            ^0
  659|     15|        total_lines += 1;
  660|     15|        let trimmed = line.trim();
  661|     15|        if trimmed.is_empty() {
  662|      0|            stats.blank_lines += 1;
  663|      0|            continue;
  664|     15|        }
  665|     15|        if in_block_comment {
  666|      2|            stats.comment_lines += 1;
  667|      2|            if trimmed.contains("*/") {
  668|      2|                in_block_comment = false;
  669|      2|                if let Some(after_comment) = trimmed.split("*/").nth(1) {
  670|      2|                    if !after_comment.trim().is_empty() && !after_comment.trim().starts_with("//") {
                                                                         ^0
  671|      0|                        stats.code_lines += 1;
  672|      2|                    }
  673|      0|                }
  674|      0|            }
  675|      2|            continue;
  676|     13|        }
  677|     13|        if in_jsx_comment {
  678|      1|            stats.comment_lines += 1;
  679|      1|            if trimmed.contains("-->") {
  680|      1|                in_jsx_comment = false;
  681|      1|                if let Some(after_comment) = trimmed.split("-->").nth(1) {
  682|      1|                    if !after_comment.trim().is_empty() {
  683|      1|                        stats.code_lines += 1;
  684|      1|                    }
                                  ^0
  685|      0|                }
  686|      0|            }
  687|      1|            continue;
  688|     12|        }
  689|     12|        if trimmed.starts_with("/*") {
  690|      3|            stats.comment_lines += 1;
  691|      3|            if let Some(before_comment) = trimmed.split("/*").next() {
  692|      3|                if !before_comment.trim().is_empty() {
  693|      0|                    stats.code_lines += 1;
  694|      3|                }
  695|      0|            }
  696|      3|            if !trimmed.contains("*/") {
  697|      2|                in_block_comment = true;
  698|      2|            } else if let Some(after_comment) = trimmed.split("*/").nth(1) {
                                             ^1               ^1
  699|      1|                if !after_comment.trim().is_empty() && !after_comment.trim().starts_with("//") {
                                                                     ^0
  700|      0|                    stats.code_lines += 1;
  701|      1|                }
  702|      0|            }
  703|      3|            continue;
  704|      9|        }
  705|      9|        if trimmed.starts_with("<!--") {
  706|      2|            stats.comment_lines += 1;
  707|      2|            if let Some(before_comment) = trimmed.split("<!--").next() {
  708|      2|                if !before_comment.trim().is_empty() {
  709|      0|                    stats.code_lines += 1;
  710|      2|                }
  711|      0|            }
  712|      2|            if !trimmed.contains("-->") {
  713|      1|                in_jsx_comment = true;
  714|      1|            } else if let Some(after_comment) = trimmed.split("-->").nth(1) {
  715|      1|                if !after_comment.trim().is_empty() {
  716|      0|                    stats.code_lines += 1;
  717|      1|                }
  718|      0|            }
  719|      2|            continue;
  720|      7|        }
  721|      7|        if trimmed.starts_with("//") {
  722|      1|            stats.comment_lines += 1;
  723|      1|            continue;
  724|      6|        }
  725|      6|        stats.code_lines += 1;
  726|       |    }
  727|      2|    Ok((stats, total_lines))
  728|      2|}
  729|       |
  730|      2|fn count_php_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  731|      2|    let mut stats = LanguageStats::default();
  732|      2|    let mut in_block_comment = false;
  733|      2|    let mut total_lines = 0;
  734|      6|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
  735|      6|        let line = line_result?;
                                            ^0
  736|      6|        total_lines += 1;
  737|      6|        let trimmed = line.trim();
  738|      6|        if trimmed.is_empty() {
  739|      0|            stats.blank_lines += 1;
  740|      0|            continue;
  741|      6|        }
  742|      6|        if in_block_comment {
  743|      0|            stats.comment_lines += 1;
  744|      0|            if trimmed.contains("*/") {
  745|      0|                in_block_comment = false;
  746|      0|                if let Some(code) = trimmed.split("*/").nth(1) {
  747|      0|                    let code_trimmed = code.trim_start();
  748|      0|                    if !code_trimmed.is_empty()
  749|      0|                        && !code_trimmed.starts_with("//")
  750|      0|                        && !code_trimmed.starts_with('#')
  751|      0|                    {
  752|      0|                        stats.code_lines += 1;
  753|      0|                    }
  754|      0|                }
  755|      0|            }
  756|      0|            continue;
  757|      6|        }
  758|      6|        if let Some(pos) = trimmed.find("/*") {
                                  ^2
  759|       |            // code before block
  760|      2|            let before = &trimmed[..pos];
  761|      2|            if !before.trim().is_empty() {
  762|      2|                stats.code_lines += 1;
  763|      2|            }
                          ^0
  764|      2|            stats.comment_lines += 1;
  765|       |            // same-line close?
  766|      2|            if let Some(end) = trimmed[pos..].find("*/") {
  767|      2|                let after = &trimmed[(pos + end + 2)..];
  768|      2|                let after_trim = after.trim_start();
  769|      2|                if !after_trim.is_empty()
  770|      2|                    && !after_trim.starts_with("//")
  771|      2|                    && !after_trim.starts_with('#')
  772|      1|                {
  773|      1|                    stats.code_lines += 1;
  774|      1|                }
  775|      0|            } else {
  776|      0|                in_block_comment = true;
  777|      0|            }
  778|      2|            continue;
  779|      4|        }
  780|      4|        if trimmed.starts_with("//") || trimmed.starts_with("#") {
  781|      0|            stats.comment_lines += 1;
  782|      0|            continue;
  783|      4|        }
  784|      4|        stats.code_lines += 1;
  785|       |    }
  786|      2|    Ok((stats, total_lines))
  787|      2|}
  788|       |
  789|      2|fn count_perl_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  790|      2|    let mut stats = LanguageStats::default();
  791|      2|    let mut in_pod_comment = false;
  792|      2|    let mut total_lines = 0;
  793|     12|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
  794|     12|        let line = line_result?;
                                            ^0
  795|     12|        total_lines += 1;
  796|     12|        let trimmed = line.trim();
  797|     12|        if trimmed.is_empty() {
  798|      1|            stats.blank_lines += 1;
  799|      1|            continue;
  800|     11|        }
  801|     11|        if trimmed.starts_with("=pod") || trimmed.starts_with("=head") {
                                                        ^9
  802|      2|            in_pod_comment = true;
  803|      2|            stats.comment_lines += 1;
  804|      2|            continue;
  805|      9|        }
  806|      9|        if trimmed.starts_with("=cut") {
  807|      2|            in_pod_comment = false;
  808|      2|            stats.comment_lines += 1;
  809|      2|            continue;
  810|      7|        }
  811|      7|        if in_pod_comment {
  812|      2|            stats.comment_lines += 1;
  813|      2|            continue;
  814|      5|        }
  815|      5|        if trimmed.starts_with('#') && !trimmed.starts_with("#!") {
                                                     ^2
  816|      1|            stats.comment_lines += 1;
  817|      1|            continue;
  818|      4|        }
  819|      4|        stats.code_lines += 1;
  820|       |    }
  821|      2|    Ok((stats, total_lines))
  822|      2|}
  823|       |
  824|       |/// Ruby: supports line comments (with a special case for shebang) and block comments delimited by "=begin" and "=end".
  825|      1|fn count_ruby_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  826|      1|    let mut stats = LanguageStats::default();
  827|      1|    let mut in_block_comment = false;
  828|      1|    let mut line_number = 0;
  829|      1|    let mut total_lines = 0;
  830|      7|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
  831|      7|        let line = line_result?;
                                            ^0
  832|      7|        total_lines += 1;
  833|      7|        line_number += 1;
  834|      7|        let trimmed = line.trim();
  835|      7|        if trimmed.is_empty() {
  836|      0|            stats.blank_lines += 1;
  837|      0|            continue;
  838|      7|        }
  839|      7|        if in_block_comment {
  840|      2|            stats.comment_lines += 1;
  841|      2|            if trimmed == "=end" {
  842|      1|                in_block_comment = false;
  843|      1|            }
  844|      2|            continue;
  845|      5|        }
  846|      5|        if trimmed.starts_with("=begin") {
  847|      1|            in_block_comment = true;
  848|      1|            stats.comment_lines += 1;
  849|      1|            continue;
  850|      4|        }
  851|      4|        if trimmed.starts_with("#") {
  852|      2|            if line_number == 1 && trimmed.starts_with("#!") {
                                                 ^1
  853|      1|                stats.code_lines += 1;
  854|      1|            } else {
  855|      1|                stats.comment_lines += 1;
  856|      1|            }
  857|      2|            continue;
  858|      2|        }
  859|      2|        stats.code_lines += 1;
  860|       |    }
  861|      1|    Ok((stats, total_lines))
  862|      1|}
  863|       |
  864|       |/// Shell: supports line comments (with a special case for shebang).
  865|      1|fn count_shell_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  866|      1|    let mut stats = LanguageStats::default();
  867|      1|    let mut line_number = 0;
  868|      1|    let mut total_lines = 0;
  869|      3|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
  870|      3|        let line = line_result?;
                                            ^0
  871|      3|        total_lines += 1;
  872|      3|        line_number += 1;
  873|      3|        let trimmed = line.trim();
  874|      3|        if trimmed.is_empty() {
  875|      0|            stats.blank_lines += 1;
  876|      0|            continue;
  877|      3|        }
  878|      3|        if trimmed.starts_with("#") {
  879|      2|            if line_number == 1 && trimmed.starts_with("#!") {
                                                 ^1
  880|      1|                stats.code_lines += 1;
  881|      1|            } else {
  882|      1|                stats.comment_lines += 1;
  883|      1|            }
  884|      2|            continue;
  885|      1|        }
  886|      1|        stats.code_lines += 1;
  887|       |    }
  888|      1|    Ok((stats, total_lines))
  889|      1|}
  890|       |
  891|       |/// Pascal: supports line comments ("//") and block comments delimited by "{" and "}" or "(*" and "*)".
  892|       |/// Improved to support nested block comments by tracking nesting level.
  893|      3|fn count_pascal_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
  894|      3|    let mut stats = LanguageStats::default();
  895|      3|    let mut total_lines = 0;
  896|      3|
  897|      3|    // Track both comment type and nesting level
  898|      3|    let mut brace_comment_level = 0; // For { } comments
  899|      3|    let mut parenthesis_comment_level = 0; // For (* *) comments
  900|       |
  901|     12|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^3                              ^0
  902|     12|        let line = line_result?;
                                            ^0
  903|     12|        total_lines += 1;
  904|     12|        let trimmed = line.trim();
  905|     12|        if trimmed.is_empty() {
  906|      0|            stats.blank_lines += 1;
  907|      0|            continue;
  908|     12|        }
  909|     12|
  910|     12|        // If in any block comment
  911|     12|        if brace_comment_level > 0 || parenthesis_comment_level > 0 {
  912|      2|            stats.comment_lines += 1;
  913|      2|
  914|      2|            // Count nested braces
  915|      2|            if brace_comment_level > 0 {
  916|      0|                brace_comment_level += trimmed.matches("{").count() as i32;
  917|      0|                brace_comment_level -= trimmed.matches("}").count() as i32;
  918|      0|
  919|      0|                // If we've closed all brace comments, check for code after the closing brace
  920|      0|                if brace_comment_level == 0 {
  921|      0|                    if let Some(after) = trimmed.split("}").last() {
  922|      0|                        if !after.trim().is_empty() && !after.trim().starts_with("//") {
  923|      0|                            stats.code_lines += 1;
  924|      0|                        }
  925|      0|                    }
  926|      0|                }
  927|      2|            }
  928|       |
  929|       |            // Count nested parenthesis comments
  930|      2|            if parenthesis_comment_level > 0 {
  931|      2|                parenthesis_comment_level += trimmed.matches("(*").count() as i32;
  932|      2|                parenthesis_comment_level -= trimmed.matches("*)").count() as i32;
  933|      2|
  934|      2|                // If we've closed all parenthesis comments, check for code after
  935|      2|                if parenthesis_comment_level == 0 {
  936|      2|                    if let Some(after) = trimmed.split("*)").last() {
  937|      2|                        if !after.trim().is_empty() && !after.trim().starts_with("//") {
                                                                     ^1
  938|      1|                            stats.code_lines += 1;
  939|      1|                        }
  940|      0|                    }
  941|      0|                }
  942|      0|            }
  943|       |
  944|      2|            continue;
  945|     10|        }
  946|     10|
  947|     10|        // Line comments
  948|     10|        if trimmed.starts_with("//") {
  949|      1|            stats.comment_lines += 1;
  950|      1|            continue;
  951|      9|        }
  952|      9|
  953|      9|        // Start of brace comment
  954|      9|        if trimmed.contains("{") {
  955|      3|            stats.comment_lines += 1;
  956|       |
  957|       |            // Check for code before the comment
  958|      3|            if let Some(before) = trimmed.split('{').next() {
  959|      3|                if !before.trim().is_empty() {
  960|      0|                    stats.code_lines += 1;
  961|      3|                }
  962|      0|            }
  963|       |
  964|      3|            brace_comment_level += 1;
  965|      3|            brace_comment_level -= trimmed.matches("}").count() as i32;
  966|      3|
  967|      3|            // If comment ends on same line
  968|      3|            if brace_comment_level == 0 {
  969|      3|                if let Some(after) = trimmed.split("}").last() {
  970|      3|                    if !after.trim().is_empty() && !after.trim().starts_with("//") {
                                                                 ^2
  971|      2|                        stats.code_lines += 1;
  972|      2|                    }
                                  ^1
  973|      0|                }
  974|      0|            }
  975|       |
  976|      3|            continue;
  977|      6|        }
  978|      6|
  979|      6|        // Start of parenthesis comment
  980|      6|        if trimmed.contains("(*") {
  981|      3|            stats.comment_lines += 1;
  982|       |
  983|       |            // Check for code before the comment
  984|      3|            if let Some(before) = trimmed.split("(*").next() {
  985|      3|                if !before.trim().is_empty() {
  986|      0|                    stats.code_lines += 1;
  987|      3|                }
  988|      0|            }
  989|       |
  990|      3|            parenthesis_comment_level += 1;
  991|      3|            parenthesis_comment_level -= trimmed.matches("*)").count() as i32;
  992|      3|
  993|      3|            // If comment ends on same line
  994|      3|            if parenthesis_comment_level == 0 {
  995|      1|                if let Some(after) = trimmed.split("*)").last() {
  996|      1|                    if !after.trim().is_empty() && !after.trim().starts_with("//") {
  997|      1|                        stats.code_lines += 1;
  998|      1|                    }
                                  ^0
  999|      0|                }
 1000|      2|            }
 1001|       |
 1002|      3|            continue;
 1003|      3|        }
 1004|      3|
 1005|      3|        // Regular code line
 1006|      3|        stats.code_lines += 1;
 1007|       |    }
 1008|       |
 1009|      3|    Ok((stats, total_lines))
 1010|      3|}
 1011|       |
 1012|       |// TOML: supports line comments with '#'.
 1013|       |// (removed duplicate count_toml_lines)
 1014|       |
 1015|       |/// Count lines for languages with hash-prefixed line comments only (e.g., YAML, TOML).
 1016|     12|fn count_hash_comment_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1017|     12|    let mut stats = LanguageStats::default();
 1018|     12|    let mut total_lines = 0;
 1019|     31|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^12                             ^0
 1020|     31|        let line = line_result?;
                                            ^0
 1021|     31|        total_lines += 1;
 1022|     31|        let trimmed = line.trim();
 1023|     31|        if trimmed.is_empty() {
 1024|      3|            stats.blank_lines += 1;
 1025|     28|        } else if trimmed.starts_with('#') {
 1026|      8|            stats.comment_lines += 1;
 1027|     20|        } else {
 1028|     20|            stats.code_lines += 1;
 1029|     20|        }
 1030|       |    }
 1031|     12|    Ok((stats, total_lines))
 1032|     12|}
 1033|       |
 1034|      2|fn count_yaml_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1035|      2|    count_hash_comment_lines(file_path)
 1036|      2|}
 1037|       |
 1038|      2|fn count_toml_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1039|      2|    count_hash_comment_lines(file_path)
 1040|      2|}
 1041|       |
 1042|      3|fn count_makefile_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1043|      3|    // Make treats leading '#' as comment. We don’t parse recipe semantics; keep it simple.
 1044|      3|    count_hash_comment_lines(file_path)
 1045|      3|}
 1046|       |
 1047|      2|fn count_dockerfile_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1048|      2|    // Dockerfile uses '#' for comments; everything else is code or blank.
 1049|      2|    count_hash_comment_lines(file_path)
 1050|      2|}
 1051|       |
 1052|      2|fn count_ini_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1053|      2|    let mut stats = LanguageStats::default();
 1054|      2|    let mut total_lines = 0;
 1055|      6|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
 1056|      6|        let line = line_result?;
                                            ^0
 1057|      6|        total_lines += 1;
 1058|      6|        let trimmed = line.trim();
 1059|      6|        if trimmed.is_empty() {
 1060|      1|            stats.blank_lines += 1;
 1061|      5|        } else if trimmed.starts_with(';') || trimmed.starts_with('#') {
                                                            ^4
 1062|      2|            stats.comment_lines += 1;
 1063|      3|        } else {
 1064|      3|            stats.code_lines += 1;
 1065|      3|        }
 1066|       |    }
 1067|      2|    Ok((stats, total_lines))
 1068|      2|}
 1069|       |
 1070|      2|fn count_hcl_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1071|      2|    let mut stats = LanguageStats::default();
 1072|      2|    let mut in_block = false;
 1073|      2|    let mut total_lines = 0;
 1074|      9|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
 1075|      9|        let line = line_result?;
                                            ^0
 1076|      9|        total_lines += 1;
 1077|      9|        let mut s = line.as_str();
 1078|      9|        let trimmed_line = s.trim();
 1079|      9|        if trimmed_line.is_empty() {
 1080|      0|            stats.blank_lines += 1;
 1081|      0|            continue;
 1082|      9|        }
 1083|       |        loop {
 1084|     11|            if in_block {
 1085|      2|                if let Some(end) = s.find("*/") {
                                          ^1
 1086|      1|                    stats.comment_lines += 1;
 1087|      1|                    s = &s[end + 2..];
 1088|      1|                    in_block = false;
 1089|      1|                    if s.trim().is_empty() {
 1090|      1|                        break;
 1091|       |                    } else {
 1092|      0|                        continue;
 1093|       |                    }
 1094|       |                } else {
 1095|      1|                    stats.comment_lines += 1;
 1096|      1|                    break;
 1097|       |                }
 1098|       |            } else {
 1099|      9|                let p_line1 = s.find("//");
 1100|      9|                let p_line2 = s.find('#');
 1101|      9|                let p_block = s.find("/*");
 1102|      9|                let mut next: Option<(&str, usize)> = None;
 1103|      9|                if let Some(i) = p_line1 {
                                          ^1
 1104|      1|                    next = Some(("//", i));
 1105|      8|                }
 1106|      9|                if let Some(i) = p_line2 {
                                          ^1
 1107|      0|                    next = match next {
 1108|      0|                        Some((k, j)) if j <= i => Some((k, j)),
 1109|      1|                        _ => Some(("#", i)),
 1110|       |                    };
 1111|      8|                }
 1112|      9|                if let Some(i) = p_block {
                                          ^4
 1113|      0|                    next = match next {
 1114|      0|                        Some((k, j)) if j <= i => Some((k, j)),
 1115|      4|                        _ => Some(("/*", i)),
 1116|       |                    };
 1117|      5|                }
 1118|      9|                match next {
 1119|       |                    None => {
 1120|      3|                        if !s.trim().is_empty() {
 1121|      3|                            stats.code_lines += 1;
 1122|      3|                        }
                                      ^0
 1123|      3|                        break;
 1124|       |                    }
 1125|      6|                    Some(("//", i)) => {
 1126|      1|                        let before = &s[..i];
 1127|      1|                        if !before.trim().is_empty() {
 1128|      0|                            stats.code_lines += 1;
 1129|      1|                        }
 1130|      1|                        stats.comment_lines += 1;
 1131|      1|                        break;
 1132|       |                    }
 1133|      5|                    Some(("#", i)) => {
 1134|      1|                        let before = &s[..i];
 1135|      1|                        if !before.trim().is_empty() {
 1136|      0|                            stats.code_lines += 1;
 1137|      1|                        }
 1138|      1|                        stats.comment_lines += 1;
 1139|      1|                        break;
 1140|       |                    }
 1141|      4|                    Some(("/*", i)) => {
 1142|      4|                        let before = &s[..i];
 1143|      4|                        if !before.trim().is_empty() {
 1144|      3|                            stats.code_lines += 1;
 1145|      3|                        }
                                      ^1
 1146|      4|                        stats.comment_lines += 1;
 1147|      4|                        s = &s[i + 2..];
 1148|      4|                        if let Some(end) = s.find("*/") {
                                                  ^3
 1149|      3|                            s = &s[end + 2..];
 1150|      3|                            if s.trim().is_empty() {
 1151|      1|                                break;
 1152|       |                            } else {
 1153|      2|                                continue;
 1154|       |                            }
 1155|       |                        } else {
 1156|      1|                            in_block = true;
 1157|      1|                            break;
 1158|       |                        }
 1159|       |                    }
 1160|      0|                    _ => unreachable!(),
 1161|       |                }
 1162|       |            }
 1163|       |        }
 1164|       |    }
 1165|      2|    Ok((stats, total_lines))
 1166|      2|}
 1167|       |
 1168|      1|fn count_rst_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1169|      1|    // Keep simple and in line with tokei: non-blank lines are code; no comments.
 1170|      1|    let mut stats = LanguageStats::default();
 1171|      1|    let mut total_lines = 0;
 1172|      6|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1173|      6|        let line = line_result?;
                                            ^0
 1174|      6|        total_lines += 1;
 1175|      6|        if line.trim().is_empty() {
 1176|      2|            stats.blank_lines += 1;
 1177|      4|        } else {
 1178|      4|            stats.code_lines += 1;
 1179|      4|        }
 1180|       |    }
 1181|      1|    Ok((stats, total_lines))
 1182|      1|}
 1183|       |
 1184|      1|fn count_velocity_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1185|      1|    // Velocity: '##' line comments, '#* ... *#' block comments. Count code before/after markers.
 1186|      1|    let mut stats = LanguageStats::default();
 1187|      1|    let mut in_block = false;
 1188|      1|    let mut total_lines = 0;
 1189|      4|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1190|      4|        let line = line_result?;
                                            ^0
 1191|      4|        total_lines += 1;
 1192|      4|        let trimmed = line.trim();
 1193|      4|        if trimmed.is_empty() {
 1194|      0|            stats.blank_lines += 1;
 1195|      0|            continue;
 1196|      4|        }
 1197|      4|        if in_block {
 1198|      1|            stats.comment_lines += 1;
 1199|      1|            if let Some(pos) = trimmed.find("*#") {
 1200|      1|                in_block = false;
 1201|      1|                let after = &trimmed[(pos + 2)..];
 1202|      1|                if !after.trim().is_empty() && !after.trim_start().starts_with("##") {
                                                             ^0
 1203|      0|                    stats.code_lines += 1;
 1204|      1|                }
 1205|      0|            }
 1206|      1|            continue;
 1207|      3|        }
 1208|      3|        if trimmed.starts_with("##") {
 1209|      1|            stats.comment_lines += 1;
 1210|      1|            continue;
 1211|      2|        }
 1212|      2|        if let Some(pos) = trimmed.find("#*") {
 1213|      2|            let before = &trimmed[..pos];
 1214|      2|            if !before.trim().is_empty() {
 1215|      1|                stats.code_lines += 1;
 1216|      1|            }
 1217|      2|            stats.comment_lines += 1;
 1218|      2|            if !trimmed[pos..].contains("*#") {
 1219|      1|                in_block = true;
 1220|      1|            } else if let Some(end) = trimmed[pos..].find("*#") {
 1221|      1|                let after = &trimmed[(pos + end + 2)..];
 1222|      1|                if !after.trim().is_empty() && !after.trim_start().starts_with("##") {
 1223|      1|                    stats.code_lines += 1;
 1224|      1|                }
                              ^0
 1225|      0|            }
 1226|      2|            continue;
 1227|      0|        }
 1228|      0|        stats.code_lines += 1;
 1229|       |    }
 1230|      1|    Ok((stats, total_lines))
 1231|      1|}
 1232|       |
 1233|      1|fn count_mustache_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1234|      1|    // Mustache: comments start with '{{!' and end at the next '}}' (may cross lines).
 1235|      1|    let mut stats = LanguageStats::default();
 1236|      1|    let mut in_comment = false;
 1237|      1|    let mut total_lines = 0;
 1238|      4|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1239|      4|        let line = line_result?;
                                            ^0
 1240|      4|        total_lines += 1;
 1241|      4|        let trimmed = line.trim();
 1242|      4|        if trimmed.is_empty() {
 1243|      0|            stats.blank_lines += 1;
 1244|      0|            continue;
 1245|      4|        }
 1246|      4|        if in_comment {
 1247|      1|            stats.comment_lines += 1;
 1248|      1|            if let Some(pos) = trimmed.find("}}") {
 1249|       |                // close
 1250|      1|                in_comment = false;
 1251|      1|                let after = &trimmed[(pos + 2)..];
 1252|      1|                if !after.trim().is_empty() {
 1253|      0|                    stats.code_lines += 1;
 1254|      1|                }
 1255|      0|            }
 1256|      1|            continue;
 1257|      3|        }
 1258|      3|        if let Some(pos) = trimmed.find("{{!") {
                                  ^2
 1259|      2|            let before = &trimmed[..pos];
 1260|      2|            if !before.trim().is_empty() {
 1261|      0|                stats.code_lines += 1;
 1262|      2|            }
 1263|      2|            stats.comment_lines += 1;
 1264|      2|            if !trimmed[pos..].contains("}}") {
 1265|      1|                in_comment = true;
 1266|      1|            } else if let Some(end) = trimmed[pos..].find("}}") {
 1267|      1|                let after = &trimmed[(pos + end + 2)..];
 1268|      1|                if !after.trim().is_empty() {
 1269|      0|                    stats.code_lines += 1;
 1270|      1|                }
 1271|      0|            }
 1272|      2|            continue;
 1273|      1|        }
 1274|      1|        stats.code_lines += 1;
 1275|       |    }
 1276|      1|    Ok((stats, total_lines))
 1277|      1|}
 1278|       |
 1279|       |// --- New classic languages ---
 1280|       |
 1281|      2|fn count_algol_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1282|      2|    // Approximate support for ALGOL 60/68 comment styles:
 1283|      2|    // - Lines beginning with 'COMMENT' (case-insensitive) treated as comment (until ';' on the same line).
 1284|      2|    // - Single-line forms like 'co ... co' and '# ... #' are treated as full-line comments if they start the line.
 1285|      2|    let mut stats = LanguageStats::default();
 1286|      2|    let mut in_comment_until_semicolon = false;
 1287|      2|    let mut total_lines = 0;
 1288|      9|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
 1289|      9|        let line = line_result?;
                                            ^0
 1290|      9|        total_lines += 1;
 1291|      9|        let trimmed = line.trim();
 1292|      9|        if trimmed.is_empty() {
 1293|      0|            stats.blank_lines += 1;
 1294|      0|            continue;
 1295|      9|        }
 1296|      9|        let lower = trimmed.to_lowercase();
 1297|      9|        if in_comment_until_semicolon {
 1298|      1|            stats.comment_lines += 1;
 1299|      1|            if lower.contains(';') {
 1300|      1|                in_comment_until_semicolon = false;
 1301|      1|            }
                          ^0
 1302|      1|            continue;
 1303|      8|        }
 1304|      8|        if lower.starts_with("comment") {
 1305|      2|            stats.comment_lines += 1;
 1306|      2|            if !lower.contains(';') {
 1307|      1|                in_comment_until_semicolon = true;
 1308|      1|            }
 1309|      2|            continue;
 1310|      6|        }
 1311|      6|        if lower.starts_with("co ") && lower.ends_with(" co") {
                                                     ^1
 1312|      1|            stats.comment_lines += 1;
 1313|      1|            continue;
 1314|      5|        }
 1315|      5|        if lower.starts_with('#') {
 1316|      1|            stats.comment_lines += 1;
 1317|      1|            continue;
 1318|      4|        }
 1319|      4|        stats.code_lines += 1;
 1320|       |    }
 1321|      2|    Ok((stats, total_lines))
 1322|      2|}
 1323|       |
 1324|      3|fn count_cobol_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1325|      3|    // COBOL: fixed format comment indicator in column 7 ('*' or '/'),
 1326|      3|    // and free-format comment starting with '*>'. We treat lines accordingly.
 1327|      3|    let mut stats = LanguageStats::default();
 1328|      3|    let mut total_lines = 0;
 1329|      6|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^3                              ^0
 1330|      6|        let line = line_result?;
                                            ^0
 1331|      6|        total_lines += 1;
 1332|      6|        if line.trim().is_empty() {
 1333|      0|            stats.blank_lines += 1;
 1334|      0|            continue;
 1335|      6|        }
 1336|      6|        let trimmed = line.trim_start();
 1337|      6|        if trimmed.starts_with("*>") {
 1338|      1|            stats.comment_lines += 1;
 1339|      1|            continue;
 1340|      5|        }
 1341|      5|        // Column 7 indicator (index 6, 0-based) in the original line
 1342|      5|        let col7 = line.chars().nth(6);
 1343|      5|        if matches!(col7, Some('*') | Some('/')) {
                         ^4
 1344|      1|            stats.comment_lines += 1;
 1345|      1|            continue;
 1346|      4|        }
 1347|      4|        stats.code_lines += 1;
 1348|       |    }
 1349|      3|    Ok((stats, total_lines))
 1350|      3|}
 1351|       |
 1352|      4|fn count_fortran_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1353|      4|    // Fortran: fixed-form comment if first column is C/c/*/D/d; '!' creates inline comment in free-form.
 1354|      4|    let mut stats = LanguageStats::default();
 1355|      4|    let mut total_lines = 0;
 1356|      7|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^4                              ^0
 1357|      7|        let line = line_result?;
                                            ^0
 1358|      7|        total_lines += 1;
 1359|      7|        if line.trim().is_empty() {
 1360|      0|            stats.blank_lines += 1;
 1361|      0|            continue;
 1362|      7|        }
 1363|      7|        let first = line.chars().next().unwrap_or(' ');
 1364|      7|        let trimmed = line.trim_start();
 1365|      7|        if matches!(first, 'C' | 'c' | '*' | 'D' | 'd') {
                         ^6
 1366|      1|            stats.comment_lines += 1;
 1367|      1|            continue;
 1368|      6|        }
 1369|      6|        if let Some(pos) = trimmed.find('!') {
                                  ^2
 1370|       |            // code before '!' counts as code; rest as comment
 1371|      2|            let before = &trimmed[..pos];
 1372|      2|            if !before.trim().is_empty() {
 1373|      1|                stats.code_lines += 1;
 1374|      1|            }
 1375|      2|            stats.comment_lines += 1;
 1376|      2|            continue;
 1377|      4|        }
 1378|      4|        stats.code_lines += 1;
 1379|       |    }
 1380|      4|    Ok((stats, total_lines))
 1381|      4|}
 1382|       |
 1383|      1|fn count_asm_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1384|      1|    // Assembly (NASM/MASM ';' comments, GAS '#' comments). Full-line only.
 1385|      1|    let mut stats = LanguageStats::default();
 1386|      1|    let mut total_lines = 0;
 1387|      3|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1388|      3|        let line = line_result?;
                                            ^0
 1389|      3|        total_lines += 1;
 1390|      3|        let trimmed = line.trim();
 1391|      3|        if trimmed.is_empty() {
 1392|      0|            stats.blank_lines += 1;
 1393|      0|            continue;
 1394|      3|        }
 1395|      3|        if trimmed.starts_with(';') || trimmed.starts_with('#') || trimmed.starts_with("//") {
                                                     ^2                          ^1
 1396|      2|            stats.comment_lines += 1;
 1397|      2|            continue;
 1398|      1|        }
 1399|      1|        stats.code_lines += 1;
 1400|       |    }
 1401|      1|    Ok((stats, total_lines))
 1402|      1|}
 1403|       |
 1404|      3|fn count_dcl_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1405|      3|    // OpenVMS DCL: comments start with '!' or '$!' on a line. Commands typically start with '$'.
 1406|      3|    let mut stats = LanguageStats::default();
 1407|      3|    let mut total_lines = 0;
 1408|      3|    let mut is_dcl: Option<bool> = None;
 1409|       |
 1410|      4|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^3                              ^0
 1411|      4|        let line = line_result?;
                                            ^0
 1412|      4|        total_lines += 1;
 1413|      4|        if is_dcl.is_none() {
 1414|      3|            let trimmed_start = line.trim_start();
 1415|      3|            if !trimmed_start.is_empty() {
 1416|      3|                is_dcl = Some(trimmed_start.starts_with('$') || trimmed_start.starts_with('!'));
                                                                              ^2
 1417|      0|            }
 1418|      1|        }
 1419|      4|        if matches!(is_dcl, Some(false)) {
                         ^2
 1420|      2|            continue;
 1421|      2|        }
 1422|      2|
 1423|      2|        let trimmed = line.trim();
 1424|      2|        if trimmed.is_empty() {
 1425|      0|            stats.blank_lines += 1;
 1426|      0|            continue;
 1427|      2|        }
 1428|      2|        if trimmed.starts_with("$!") || trimmed.starts_with('!') {
                                                      ^1
 1429|      1|            stats.comment_lines += 1;
 1430|      1|            continue;
 1431|      1|        }
 1432|      1|        stats.code_lines += 1;
 1433|       |    }
 1434|       |
 1435|      3|    if matches!(is_dcl, Some(false)) {
                     ^1
 1436|      2|        Ok((LanguageStats::default(), total_lines))
 1437|       |    } else {
 1438|      1|        Ok((stats, total_lines))
 1439|       |    }
 1440|      3|}
 1441|       |
 1442|      2|fn count_iplan_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1443|      2|    // PSS/E IPLAN: supports C-style block comments /* ... */ and '!' full-line comments.
 1444|      2|    let mut stats = LanguageStats::default();
 1445|      2|    let mut in_block = false;
 1446|      2|    let mut total_lines = 0;
 1447|      7|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^2                              ^0
 1448|      7|        let line = line_result?;
                                            ^0
 1449|      7|        total_lines += 1;
 1450|      7|        let trimmed = line.trim();
 1451|      7|        if trimmed.is_empty() {
 1452|      0|            stats.blank_lines += 1;
 1453|      0|            continue;
 1454|      7|        }
 1455|      7|        if in_block {
 1456|      1|            stats.comment_lines += 1;
 1457|      1|            if let Some(pos) = trimmed.find("*/") {
 1458|      1|                in_block = false;
 1459|      1|                let after = &trimmed[(pos + 2)..];
 1460|      1|                if !after.trim().is_empty() && !after.trim_start().starts_with('!') {
 1461|      0|                    stats.code_lines += 1;
 1462|      1|                }
 1463|      0|            }
 1464|      1|            continue;
 1465|      6|        }
 1466|      6|        if trimmed.starts_with('!') {
 1467|      1|            stats.comment_lines += 1;
 1468|      1|            continue;
 1469|      5|        }
 1470|      5|        if let Some(pos) = trimmed.find("/*") {
                                  ^3
 1471|      3|            let before = &trimmed[..pos];
 1472|      3|            if !before.trim().is_empty() {
 1473|      1|                stats.code_lines += 1;
 1474|      2|            }
 1475|      3|            stats.comment_lines += 1;
 1476|      3|            if !trimmed[pos..].contains("*/") {
 1477|      1|                in_block = true;
 1478|      2|            } else if let Some(end) = trimmed[pos..].find("*/") {
 1479|      2|                let after = &trimmed[(pos + end + 2)..];
 1480|      2|                if !after.trim().is_empty() && !after.trim_start().starts_with('!') {
                                                             ^1
 1481|      0|                    stats.code_lines += 1;
 1482|      2|                }
 1483|      0|            }
 1484|      3|            continue;
 1485|      2|        }
 1486|      2|        stats.code_lines += 1;
 1487|       |    }
 1488|      2|    Ok((stats, total_lines))
 1489|      2|}
 1490|       |
 1491|      3|fn count_cmake_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1492|      3|    // CMake uses '#' for line comments; no block comment syntax.
 1493|      3|    count_hash_comment_lines(file_path)
 1494|      3|}
 1495|       |
 1496|      4|fn count_powershell_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1497|      4|    // PowerShell supports '#' line comments and <# ... #> block comments.
 1498|      4|    let mut stats = LanguageStats::default();
 1499|      4|    let mut in_block = false;
 1500|      4|    let mut total_lines = 0;
 1501|     14|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^4                              ^0
 1502|     14|        let line = line_result?;
                                            ^0
 1503|     14|        total_lines += 1;
 1504|     14|        let mut s = line.as_str();
 1505|     14|        let trimmed_line = s.trim();
 1506|     14|        if trimmed_line.is_empty() {
 1507|      0|            stats.blank_lines += 1;
 1508|      0|            continue;
 1509|     14|        }
 1510|       |        loop {
 1511|     19|            if in_block {
 1512|      5|                if let Some(end) = s.find("#>") {
                                          ^3
 1513|      3|                    stats.comment_lines += 1;
 1514|      3|                    s = &s[end + 2..];
 1515|      3|                    in_block = false;
 1516|      3|                    if s.trim().is_empty() {
 1517|      1|                        break;
 1518|       |                    } else {
 1519|      2|                        continue;
 1520|       |                    }
 1521|       |                } else {
 1522|      2|                    stats.comment_lines += 1;
 1523|      2|                    break;
 1524|       |                }
 1525|       |            } else {
 1526|     14|                let p_line = s.find('#');
 1527|     14|                let p_block = s.find("<#");
 1528|     14|                match (p_line, p_block) {
 1529|       |                    (None, None) => {
 1530|      6|                        if !s.trim().is_empty() {
 1531|      6|                            stats.code_lines += 1;
 1532|      6|                        }
                                      ^0
 1533|      6|                        break;
 1534|       |                    }
 1535|      2|                    (Some(pl), None) => {
 1536|      2|                        let before = &s[..pl];
 1537|      2|                        if !before.trim().is_empty() {
 1538|      0|                            stats.code_lines += 1;
 1539|      2|                        }
 1540|      2|                        stats.comment_lines += 1;
 1541|      2|                        break;
 1542|       |                    }
 1543|      0|                    (None, Some(pb)) => {
 1544|      0|                        let before = &s[..pb];
 1545|      0|                        if !before.trim().is_empty() {
 1546|      0|                            stats.code_lines += 1;
 1547|      0|                        }
 1548|      0|                        stats.comment_lines += 1;
 1549|      0|                        s = &s[pb + 2..];
 1550|      0|                        if let Some(end) = s.find("#>") {
 1551|      0|                            s = &s[end + 2..];
 1552|      0|                            if s.trim().is_empty() {
 1553|      0|                                break;
 1554|       |                            } else {
 1555|      0|                                continue;
 1556|       |                            }
 1557|       |                        } else {
 1558|      0|                            in_block = true;
 1559|      0|                            break;
 1560|       |                        }
 1561|       |                    }
 1562|      6|                    (Some(pl), Some(pb)) => {
 1563|      6|                        if pl < pb {
 1564|      0|                            let before = &s[..pl];
 1565|      0|                            if !before.trim().is_empty() {
 1566|      0|                                stats.code_lines += 1;
 1567|      0|                            }
 1568|      0|                            stats.comment_lines += 1;
 1569|      0|                            break;
 1570|       |                        } else {
 1571|      6|                            let before = &s[..pb];
 1572|      6|                            if !before.trim().is_empty() {
 1573|      3|                                stats.code_lines += 1;
 1574|      3|                            }
 1575|      6|                            stats.comment_lines += 1;
 1576|      6|                            s = &s[pb + 2..];
 1577|      6|                            if let Some(end) = s.find("#>") {
                                                      ^3
 1578|      3|                                s = &s[end + 2..];
 1579|      3|                                if s.trim().is_empty() {
 1580|      0|                                    break;
 1581|       |                                } else {
 1582|      3|                                    continue;
 1583|       |                                }
 1584|       |                            } else {
 1585|      3|                                in_block = true;
 1586|      3|                                break;
 1587|       |                            }
 1588|       |                        }
 1589|       |                    }
 1590|       |                }
 1591|       |            }
 1592|       |        }
 1593|       |    }
 1594|      4|    Ok((stats, total_lines))
 1595|      4|}
 1596|       |
 1597|      1|fn count_batch_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1598|      1|    // Batch files treat lines starting with REM (case-insensitive) or :: as comments.
 1599|      1|    let mut stats = LanguageStats::default();
 1600|      1|    let mut total_lines = 0;
 1601|      4|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1602|      4|        let line = line_result?;
                                            ^0
 1603|      4|        total_lines += 1;
 1604|      4|        let trimmed = line.trim();
 1605|      4|        if trimmed.is_empty() {
 1606|      0|            stats.blank_lines += 1;
 1607|      0|            continue;
 1608|      4|        }
 1609|      4|        let upper = trimmed.to_uppercase();
 1610|      4|        if upper.starts_with("REM ") || upper == "REM" || trimmed.starts_with("::") {
                                                      ^3                ^3
 1611|      2|            stats.comment_lines += 1;
 1612|      2|        } else {
 1613|      2|            stats.code_lines += 1;
 1614|      2|        }
 1615|       |    }
 1616|      1|    Ok((stats, total_lines))
 1617|      1|}
 1618|       |
 1619|      1|fn count_tcl_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1620|      1|    // TCL: '#' starts a comment; shebang on first line counts as code like shell.
 1621|      1|    let mut stats = LanguageStats::default();
 1622|      1|    let mut line_no = 0u64;
 1623|      1|    let mut total_lines = 0;
 1624|      3|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1625|      3|        let line = line_result?;
                                            ^0
 1626|      3|        total_lines += 1;
 1627|      3|        line_no += 1;
 1628|      3|        let trimmed = line.trim();
 1629|      3|        if trimmed.is_empty() {
 1630|      0|            stats.blank_lines += 1;
 1631|      0|            continue;
 1632|      3|        }
 1633|      3|        if trimmed.starts_with('#') {
 1634|      2|            if line_no == 1 && trimmed.starts_with("#!") {
                                             ^1
 1635|      1|                stats.code_lines += 1;
 1636|      1|            } else {
 1637|      1|                stats.comment_lines += 1;
 1638|      1|            }
 1639|      2|            continue;
 1640|      1|        }
 1641|      1|        stats.code_lines += 1;
 1642|       |    }
 1643|      1|    Ok((stats, total_lines))
 1644|      1|}
 1645|       |
 1646|       |/// JSON has no comments per spec; count non-blank as code.
 1647|      1|fn count_json_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1648|      1|    let mut stats = LanguageStats::default();
 1649|      1|    let mut total_lines = 0;
 1650|      5|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^1                              ^0
 1651|      5|        let line = line_result?;
                                            ^0
 1652|      5|        total_lines += 1;
 1653|      5|        if line.trim().is_empty() {
 1654|      1|            stats.blank_lines += 1;
 1655|      4|        } else {
 1656|      4|            stats.code_lines += 1;
 1657|      4|        }
 1658|       |    }
 1659|      1|    Ok((stats, total_lines))
 1660|      1|}
 1661|       |
 1662|       |/// Shared XML/HTML style comment handling for <!-- ... -->. Everything else non-blank is code.
 1663|      5|fn count_xml_like_lines(file_path: &Path) -> io::Result<(LanguageStats, u64)> {
 1664|      5|    let mut stats = LanguageStats::default();
 1665|      5|    let mut in_comment = false;
 1666|      5|    let mut total_lines = 0;
 1667|     19|    for line_result in read_file_lines_lossy(file_path)? {
                                     ^5                              ^0
 1668|     19|        let line = line_result?;
                                            ^0
 1669|     19|        total_lines += 1;
 1670|     19|        let mut s = line.as_str();
 1671|     19|        let trimmed_line = s.trim();
 1672|     19|        if trimmed_line.is_empty() {
 1673|      0|            stats.blank_lines += 1;
 1674|      0|            continue;
 1675|     19|        }
 1676|       |        loop {
 1677|     23|            if in_comment {
 1678|      4|                if let Some(end) = s.find("-->") {
                                          ^2
 1679|      2|                    stats.comment_lines += 1;
 1680|      2|                    s = &s[end + 3..];
 1681|      2|                    in_comment = false;
 1682|      2|                    if s.trim().is_empty() {
 1683|      2|                        break;
 1684|       |                    } else {
 1685|      0|                        continue;
 1686|       |                    }
 1687|       |                } else {
 1688|      2|                    stats.comment_lines += 1;
 1689|      2|                    break;
 1690|       |                }
 1691|     19|            } else if let Some(pos) = s.find("<!--") {
                                             ^8
 1692|      8|                let before = &s[..pos];
 1693|      8|                if !before.trim().is_empty() {
 1694|      4|                    stats.code_lines += 1;
 1695|      4|                }
 1696|      8|                stats.comment_lines += 1;
 1697|      8|                s = &s[pos + 4..];
 1698|      8|                if let Some(end) = s.find("-->") {
                                          ^6
 1699|      6|                    s = &s[end + 3..];
 1700|      6|                    if s.trim().is_empty() {
 1701|      2|                        break;
 1702|       |                    } else {
 1703|      4|                        continue;
 1704|       |                    }
 1705|       |                } else {
 1706|      2|                    in_comment = true;
 1707|      2|                    break;
 1708|       |                }
 1709|       |            } else {
 1710|     11|                if !s.trim().is_empty() {
 1711|     11|                    stats.code_lines += 1;
 1712|     11|                }
                              ^0
 1713|     11|                break;
 1714|       |            }
 1715|       |        }
 1716|       |    }
 1717|      5|    Ok((stats, total_lines))
 1718|      5|}
 1719|       |
 1720|       |/// Recursively scan directories and collect statistics.
 1721|       |/// Added error tracking and directory depth limiting to prevent stack overflow.
 1722|     21|fn should_process_file(filespec: Option<&Pattern>, root_path: &Path, file_path: &Path) -> bool {
 1723|     21|    filespec
 1724|     21|        .map(|pattern| filespec_matches(pattern, root_path, file_path))
                                     ^6
 1725|     21|        .unwrap_or(true)
 1726|     21|}
 1727|       |
 1728|      6|fn filespec_matches(pattern: &Pattern, root_path: &Path, file_path: &Path) -> bool {
 1729|      6|    if file_path
 1730|      6|        .file_name()
 1731|      6|        .and_then(|name| name.to_str())
 1732|      6|        .map(|name| pattern.matches(name))
 1733|      6|        .unwrap_or(false)
 1734|       |    {
 1735|      3|        return true;
 1736|      3|    }
 1737|       |
 1738|      3|    let relative = match file_path.strip_prefix(root_path) {
 1739|      3|        Ok(rel) => rel,
 1740|      0|        Err(_) => return false,
 1741|       |    };
 1742|       |
 1743|      3|    let rel_str = match relative.to_str() {
 1744|      3|        Some(s) => s.replace('\\', "/"),
 1745|      0|        None => return false,
 1746|       |    };
 1747|       |
 1748|      3|    pattern.matches(&rel_str)
 1749|      6|}
 1750|       |
 1751|       |#[allow(clippy::too_many_arguments)]
 1752|     21|fn process_file(
 1753|     21|    file_path: &Path,
 1754|     21|    args: &Args,
 1755|     21|    root_path: &Path,
 1756|     21|    metrics: &mut PerformanceMetrics,
 1757|     21|    stats: &mut HashMap<PathBuf, DirectoryStats>,
 1758|     21|    entries_count: &mut usize,
 1759|     21|    error_count: &mut usize,
 1760|     21|    filespec: Option<&Pattern>,
 1761|     21|) -> io::Result<()> {
 1762|     21|    if !should_process_file(filespec, root_path, file_path) {
 1763|      3|        return Ok(());
 1764|     18|    }
 1765|     18|
 1766|     18|    *entries_count += 1;
 1767|     18|    if *entries_count > args.max_entries {
 1768|      1|        return Err(io::Error::other("Too many entries in directory tree"));
 1769|     17|    }
 1770|       |
 1771|     17|    let Some(language) = file_path
                           ^16
 1772|     17|        .file_name()
 1773|     17|        .and_then(|name| name.to_str())
 1774|     17|        .and_then(get_language_from_extension)
 1775|       |    else {
 1776|      1|        return Ok(());
 1777|       |    };
 1778|       |
 1779|     16|    match count_lines_with_stats(file_path) {
 1780|     16|        Ok((raw_stats, total_lines)) => {
 1781|     16|            let file_stats = normalize_stats(raw_stats, total_lines);
 1782|     16|            metrics.update(total_lines);
 1783|     16|            let total_line_kinds =
 1784|     16|                file_stats.code_lines + file_stats.comment_lines + file_stats.blank_lines;
 1785|     16|            if total_line_kinds > 0 || total_lines == 0 {
                                                     ^2
 1786|     15|                let dir_path = file_path
 1787|     15|                    .parent()
 1788|     15|                    .map(Path::to_path_buf)
 1789|     15|                    .unwrap_or_default();
 1790|     15|                let dir_stats = stats.entry(dir_path).or_default();
 1791|     15|                let (count, lang_stats) = dir_stats
 1792|     15|                    .language_stats
 1793|     15|                    .entry(language.to_string())
 1794|     15|                    .or_insert((0, LanguageStats::default()));
 1795|     15|                *count += 1;
 1796|     15|                lang_stats.code_lines += file_stats.code_lines;
 1797|     15|                lang_stats.comment_lines += file_stats.comment_lines;
 1798|     15|                lang_stats.blank_lines += file_stats.blank_lines;
 1799|     15|                lang_stats.overlap_lines += file_stats.overlap_lines;
 1800|     15|
 1801|     15|                if args.verbose {
 1802|      1|                    println!("File: {}", file_path.display());
 1803|      1|                    println!("  Code lines: {}", file_stats.code_lines);
 1804|      1|                    println!("  Comment lines: {}", file_stats.comment_lines);
 1805|      1|                    println!("  Blank lines: {}", file_stats.blank_lines);
 1806|      1|                    println!("  Mixed code/comment lines: {}", file_stats.overlap_lines);
 1807|      1|                    println!();
 1808|     14|                }
 1809|      1|            }
 1810|       |        }
 1811|      0|        Err(err) => {
 1812|      0|            eprintln!("Error counting lines in {}: {}", file_path.display(), err);
 1813|      0|            *error_count += 1;
 1814|      0|        }
 1815|       |    }
 1816|       |
 1817|     16|    Ok(())
 1818|     21|}
 1819|       |
 1820|       |#[allow(clippy::too_many_arguments)]
 1821|     18|fn scan_directory_impl(
 1822|     18|    path: &Path,
 1823|     18|    args: &Args,
 1824|     18|    root_path: &Path,
 1825|     18|    metrics: &mut PerformanceMetrics,
 1826|     18|    current_depth: usize,
 1827|     18|    entries_count: &mut usize,
 1828|     18|    error_count: &mut usize,
 1829|     18|    filespec: Option<&Pattern>,
 1830|     18|) -> io::Result<HashMap<PathBuf, DirectoryStats>> {
 1831|     18|    if current_depth > args.max_depth {
 1832|      1|        eprintln!(
 1833|      1|            "Warning: Maximum directory depth ({}) reached at {}",
 1834|      1|            args.max_depth,
 1835|      1|            path.display()
 1836|      1|        );
 1837|      1|        *error_count += 1;
 1838|      1|        return Ok(HashMap::new());
 1839|     17|    }
 1840|     17|
 1841|     17|    if args.non_recursive && current_depth > 0 {
                                           ^2
 1842|      0|        return Ok(HashMap::new());
 1843|     17|    }
 1844|       |
 1845|     17|    let mut stats: HashMap<PathBuf, DirectoryStats> =
 1846|     17|        HashMap::with_capacity(if path.is_dir() { 128 } else { 1 });
                                                                             ^0
 1847|       |
 1848|     17|    if is_ignored_dir(path) || args.ignore.iter().any(|d| path.ends_with(Path::new(d))) {
                                             ^16                        ^2                          ^16
 1849|      1|        return Ok(stats);
 1850|     16|    }
 1851|       |
 1852|     16|    let metadata = match fs::metadata(path) {
 1853|     16|        Ok(meta) => meta,
 1854|      0|        Err(err) => {
 1855|      0|            eprintln!("Error reading metadata for {}: {}", path.display(), err);
 1856|      0|            *error_count += 1;
 1857|      0|            return Ok(stats);
 1858|       |        }
 1859|       |    };
 1860|       |
 1861|     16|    if metadata.is_file() {
 1862|      0|        process_file(
 1863|      0|            path,
 1864|      0|            args,
 1865|      0|            root_path,
 1866|      0|            metrics,
 1867|      0|            &mut stats,
 1868|      0|            entries_count,
 1869|      0|            error_count,
 1870|      0|            filespec,
 1871|      0|        )?;
 1872|      0|        return Ok(stats);
 1873|     16|    }
 1874|     16|
 1875|     16|    if !metadata.is_dir() {
 1876|      0|        return Ok(stats);
 1877|     16|    }
 1878|       |
 1879|     16|    let read_dir = match fs::read_dir(path) {
 1880|     16|        Ok(iter) => iter,
 1881|      0|        Err(err) => {
 1882|      0|            eprintln!("Error reading directory {}: {}", path.display(), err);
 1883|      0|            *error_count += 1;
 1884|      0|            return Ok(stats);
 1885|       |        }
 1886|       |    };
 1887|       |
 1888|     44|    for entry_result in read_dir {
                      ^29
 1889|     29|        let entry = match entry_result {
 1890|     29|            Ok(entry) => entry,
 1891|      0|            Err(err) => {
 1892|      0|                eprintln!("Error reading entry in {}: {}", path.display(), err);
 1893|      0|                *error_count += 1;
 1894|      0|                continue;
 1895|       |            }
 1896|       |        };
 1897|       |
 1898|     29|        let entry_path = entry.path();
 1899|     29|        let file_type = match entry.file_type() {
 1900|     29|            Ok(ft) => ft,
 1901|      0|            Err(err) => {
 1902|      0|                eprintln!("Error reading type for {}: {}", entry_path.display(), err);
 1903|      0|                *error_count += 1;
 1904|      0|                continue;
 1905|       |            }
 1906|       |        };
 1907|       |
 1908|     29|        if file_type.is_dir() && !file_type.is_symlink() {
                                               ^8
 1909|      8|            if args.non_recursive {
 1910|      2|                continue;
 1911|      6|            }
 1912|      6|            match scan_directory_impl(
 1913|      6|                &entry_path,
 1914|      6|                args,
 1915|      6|                root_path,
 1916|      6|                metrics,
 1917|      6|                current_depth + 1,
 1918|      6|                entries_count,
 1919|      6|                error_count,
 1920|      6|                filespec,
 1921|      6|            ) {
 1922|      6|                Ok(sub_stats) => {
 1923|     10|                    for (dir, stat) in sub_stats {
                                       ^4
 1924|      4|                        if let Some(existing) = stats.get_mut(&dir) {
                                                  ^0
 1925|      0|                            for (lang, (count, lang_stats)) in stat.language_stats {
 1926|      0|                                let (existing_count, existing_stats) = existing
 1927|      0|                                    .language_stats
 1928|      0|                                    .entry(lang)
 1929|      0|                                    .or_insert((0, LanguageStats::default()));
 1930|      0|                                *existing_count += count;
 1931|      0|                                existing_stats.code_lines += lang_stats.code_lines;
 1932|      0|                                existing_stats.comment_lines += lang_stats.comment_lines;
 1933|      0|                                existing_stats.blank_lines += lang_stats.blank_lines;
 1934|      0|                                existing_stats.overlap_lines += lang_stats.overlap_lines;
 1935|      0|                            }
 1936|      4|                        } else {
 1937|      4|                            stats.insert(dir, stat);
 1938|      4|                        }
 1939|       |                    }
 1940|       |                }
 1941|      0|                Err(err) => {
 1942|      0|                    eprintln!("Error scanning directory {}: {}", entry_path.display(), err);
 1943|      0|                    *error_count += 1;
 1944|      0|                }
 1945|       |            }
 1946|     21|        } else if file_type.is_file() && !file_type.is_symlink() {
 1947|     21|            process_file(
 1948|     21|                &entry_path,
 1949|     21|                args,
 1950|     21|                root_path,
 1951|     21|                metrics,
 1952|     21|                &mut stats,
 1953|     21|                entries_count,
 1954|     21|                error_count,
 1955|     21|                filespec,
 1956|     21|            )?;
                           ^1
 1957|      0|        }
 1958|       |    }
 1959|       |
 1960|     15|    Ok(stats)
 1961|     18|}
 1962|       |
 1963|     13|fn scan_directory(
 1964|     13|    path: &Path,
 1965|     13|    args: &Args,
 1966|     13|    _current_dir: &Path,
 1967|     13|    metrics: &mut PerformanceMetrics,
 1968|     13|    current_depth: usize,
 1969|     13|    entries_count: &mut usize,
 1970|     13|    error_count: &mut usize,
 1971|     13|) -> io::Result<HashMap<PathBuf, DirectoryStats>> {
 1972|     13|    let filespec_pattern = match args.filespec.as_deref() {
                      ^12
 1973|      4|        Some(spec) => Some(Pattern::new(spec).map_err(|err| {
 1974|      1|            io::Error::new(
 1975|      1|                io::ErrorKind::InvalidInput,
 1976|      1|                format!("Invalid filespec pattern '{}': {}", spec, err),
 1977|      1|            )
 1978|      4|        })?),
                        ^1
 1979|      9|        None => None,
 1980|       |    };
 1981|       |
 1982|     12|    let root_path = fs::canonicalize(path).unwrap_or_else(|_| path.to_path_buf());
                                                                            ^0
 1983|     12|
 1984|     12|    scan_directory_impl(
 1985|     12|        &root_path,
 1986|     12|        args,
 1987|     12|        &root_path,
 1988|     12|        metrics,
 1989|     12|        current_depth,
 1990|     12|        entries_count,
 1991|     12|        error_count,
 1992|     12|        filespec_pattern.as_ref(),
 1993|     12|    )
 1994|     13|}
 1995|       |
 1996|       |/// Helper function to print stats for a language
 1997|      5|fn format_language_stats_line(
 1998|      5|    prefix: &str,
 1999|      5|    lang: &str,
 2000|      5|    file_count: u64,
 2001|      5|    stats: &LanguageStats,
 2002|      5|) -> String {
 2003|      5|    format!(
 2004|      5|        "{:<40} {:<width$} {:>8} {:>10} {:>10} {:>10} {:>10}",
 2005|      5|        prefix,
 2006|      5|        lang,
 2007|      5|        file_count,
 2008|      5|        stats.code_lines,
 2009|      5|        stats.comment_lines,
 2010|      5|        stats.overlap_lines,
 2011|      5|        stats.blank_lines,
 2012|      5|        width = LANG_WIDTH
 2013|      5|    )
 2014|      5|}
 2015|       |
 2016|      4|fn print_language_stats(prefix: &str, lang: &str, file_count: u64, stats: &LanguageStats) {
 2017|      4|    // Keep rows uncolored to ensure ANSI-safe alignment; headers are colored separately.
 2018|      4|    println!(
 2019|      4|        "{}",
 2020|      4|        format_language_stats_line(prefix, lang, file_count, stats)
 2021|      4|    );
 2022|      4|}
 2023|       |
 2024|      3|fn main() -> io::Result<()> {
 2025|      3|    let args = Args::parse();
 2026|      3|    let mut metrics = PerformanceMetrics::new();
 2027|      3|    run_cli_with_metrics(args, &mut metrics)
 2028|      3|}
 2029|       |
 2030|      3|fn run_cli_with_metrics(args: Args, metrics: &mut PerformanceMetrics) -> io::Result<()> {
 2031|      3|    println!(
 2032|      3|        "{} {}",
 2033|      3|        env!("CARGO_PKG_NAME").bright_cyan().bold(),
 2034|      3|        format!("v{}", env!("CARGO_PKG_VERSION")).bright_yellow()
 2035|      3|    );
 2036|      3|
 2037|      3|    let path = Path::new(&args.path);
 2038|      3|    let current_dir = env::current_dir()?;
                                                      ^0
 2039|      3|    let mut error_count = 0;
 2040|      3|
 2041|      3|    if !path.exists() {
 2042|      1|        return Err(io::Error::new(
 2043|      1|            io::ErrorKind::NotFound,
 2044|      1|            format!("Path does not exist: {}", path.display()),
 2045|      1|        ));
 2046|      2|    }
 2047|      2|
 2048|      2|    println!("Starting source code analysis...");
 2049|      2|    // Start with depth 0 and track errors
 2050|      2|    let mut entries_count: usize = 0;
 2051|      2|    let stats = scan_directory(
 2052|      2|        path,
 2053|      2|        &args,
 2054|      2|        &current_dir,
 2055|      2|        metrics,
 2056|      2|        0,
 2057|      2|        &mut entries_count,
 2058|      2|        &mut error_count,
 2059|      2|    )?;
                   ^0
 2060|      2|    metrics.print_final_stats();
 2061|      2|    let files_processed = metrics.files_processed.load(Ordering::Relaxed);
 2062|      2|    let lines_processed = metrics.lines_processed.load(Ordering::Relaxed);
 2063|      2|
 2064|      2|    // Print detailed analysis with fixed-width directory field.
 2065|      2|    let mut total_by_language: HashMap<String, (u64, LanguageStats)> = HashMap::new();
 2066|      2|    let mut sorted_stats: Vec<_> = stats.iter().collect();
 2067|      2|    sorted_stats.sort_by(|(a, _), (b, _)| a.to_string_lossy().cmp(&b.to_string_lossy()));
                                                        ^0
 2068|      2|
 2069|      2|    println!("\n\nDetailed source code analysis:");
 2070|      2|    println!("{}", "-".repeat(112));
 2071|      2|    println!(
 2072|      2|        "{:<40} {:<width$} {:>8} {:>10} {:>10} {:>10} {:>10}",
 2073|      2|        "Directory",
 2074|      2|        "Language",
 2075|      2|        "Files",
 2076|      2|        "Code",
 2077|      2|        "Comments",
 2078|      2|        "Mixed",
 2079|      2|        "Blank",
 2080|      2|        width = LANG_WIDTH
 2081|      2|    );
 2082|      2|    println!("{}", "-".repeat(112));
 2083|       |
 2084|      4|    for (path, dir_stats) in &sorted_stats {
                       ^2
 2085|       |        // Use a reference to avoid unnecessary string cloning
 2086|      2|        let raw_display = match path.strip_prefix(&current_dir) {
 2087|      0|            Ok(p) if p.as_os_str().is_empty() => ".",
 2088|      0|            Ok(p) => p.to_str().unwrap_or(path.to_str().unwrap_or("")),
 2089|      2|            Err(_) => path.to_str().unwrap_or(""),
 2090|       |        };
 2091|       |
 2092|       |        // Truncate the directory name from the start if it is too long.
 2093|      2|        let display_path = truncate_start(raw_display, DIR_WIDTH);
 2094|      2|
 2095|      2|        let mut languages: Vec<_> = dir_stats.language_stats.iter().collect();
 2096|      2|        languages.sort_by(|(a, _), (b, _)| a.cmp(b));
                                                         ^0
 2097|       |
 2098|      4|        for (lang, (file_count, lang_stats)) in &languages {
                           ^2
 2099|      2|            print_language_stats(&display_path, lang, *file_count, lang_stats);
 2100|      2|
 2101|      2|            let (total_count, total_stats) = total_by_language
 2102|      2|                .entry(lang.to_string())
 2103|      2|                .or_insert((0, LanguageStats::default()));
 2104|      2|            *total_count += file_count;
 2105|      2|            total_stats.code_lines += lang_stats.code_lines;
 2106|      2|            total_stats.comment_lines += lang_stats.comment_lines;
 2107|      2|            total_stats.blank_lines += lang_stats.blank_lines;
 2108|      2|            total_stats.overlap_lines += lang_stats.overlap_lines;
 2109|      2|        }
 2110|       |    }
 2111|       |
 2112|      2|    println!("{:-<112}", "");
 2113|      2|    println!("Totals by language:");
 2114|      2|
 2115|      2|    let mut sorted_totals: Vec<_> = total_by_language.iter().collect();
 2116|      2|    sorted_totals.sort_by(|(a, _), (b, _)| a.cmp(b));
                                                         ^0
 2117|       |
 2118|      4|    for (lang, (file_count, stats)) in sorted_totals {
                       ^2
 2119|      2|        print_language_stats("", lang, *file_count, stats);
 2120|      2|    }
 2121|       |
 2122|      2|    let mut grand_total = LanguageStats::default();
 2123|       |
 2124|      2|    for (_, (_files, stats)) in total_by_language.iter() {
 2125|      2|        grand_total.code_lines += stats.code_lines;
 2126|      2|        grand_total.comment_lines += stats.comment_lines;
 2127|      2|        grand_total.blank_lines += stats.blank_lines;
 2128|      2|        grand_total.overlap_lines += stats.overlap_lines;
 2129|      2|    }
 2130|       |
 2131|      2|    if files_processed > 0 || lines_processed > 0 {
                                            ^0
 2132|      2|        println!("\n{}", "Overall Summary:".blue().bold());
 2133|      2|        println!(
 2134|      2|            "Total files processed: {}",
 2135|      2|            files_processed.to_string().bright_yellow()
 2136|      2|        );
 2137|      2|        println!(
 2138|      2|            "Total lines processed: {}",
 2139|      2|            lines_processed.to_string().bright_yellow()
 2140|      2|        );
 2141|      2|        println!(
 2142|      2|            "Code lines:     {} ({})",
 2143|      2|            grand_total.code_lines.to_string().bright_yellow(),
 2144|      2|            format!(
 2145|      2|                "{:.1}%",
 2146|      2|                safe_percentage(grand_total.code_lines, lines_processed)
 2147|      2|            )
 2148|      2|            .bright_yellow()
 2149|      2|        );
 2150|      2|        println!(
 2151|      2|            "Comment lines:  {} ({})",
 2152|      2|            grand_total.comment_lines.to_string().bright_yellow(),
 2153|      2|            format!(
 2154|      2|                "{:.1}%",
 2155|      2|                safe_percentage(grand_total.comment_lines, lines_processed)
 2156|      2|            )
 2157|      2|            .bright_yellow()
 2158|      2|        );
 2159|      2|        println!(
 2160|      2|            "Mixed lines:    {} ({})",
 2161|      2|            grand_total.overlap_lines.to_string().bright_yellow(),
 2162|      2|            format!(
 2163|      2|                "{:.1}%",
 2164|      2|                safe_percentage(grand_total.overlap_lines, lines_processed)
 2165|      2|            )
 2166|      2|            .bright_yellow()
 2167|      2|        );
 2168|      2|        println!(
 2169|      2|            "Blank lines:    {} ({})",
 2170|      2|            grand_total.blank_lines.to_string().bright_yellow(),
 2171|      2|            format!(
 2172|      2|                "{:.1}%",
 2173|      2|                safe_percentage(grand_total.blank_lines, lines_processed)
 2174|      2|            )
 2175|      2|            .bright_yellow()
 2176|      2|        );
 2177|      2|
 2178|      2|        if error_count > 0 {
 2179|      0|            println!(
 2180|      0|                "\n{}: {}",
 2181|      0|                "Warning".red().bold(),
 2182|      0|                error_count.to_string().bright_yellow()
 2183|      0|            );
 2184|      2|        }
 2185|      0|    }
 2186|       |
 2187|      2|    Ok(())
 2188|      3|}
 2189|       |
 2190|       |#[cfg(test)]
 2191|       |mod tests {
 2192|       |    use super::*;
 2193|       |    use std::fs::{self, File};
 2194|       |    use std::io::{self, Write};
 2195|       |    use std::sync::{Arc, Mutex};
 2196|       |    use std::time::Duration;
 2197|       |    use tempfile::TempDir;
 2198|       |
 2199|     11|    fn test_args() -> Args {
 2200|     11|        Args {
 2201|     11|            path: String::from("."),
 2202|     11|            ignore: Vec::new(),
 2203|     11|            verbose: false,
 2204|     11|            max_entries: 1000000,
 2205|     11|            max_depth: 100,
 2206|     11|            non_recursive: false,
 2207|     11|            filespec: None,
 2208|     11|        }
 2209|     11|    }
 2210|       |
 2211|     11|    fn test_metrics() -> PerformanceMetrics {
 2212|     11|        PerformanceMetrics::with_writer(Box::new(io::sink()), false)
 2213|     11|    }
 2214|       |
 2215|     92|    fn create_test_file(dir: &Path, name: &str, content: &str) -> io::Result<()> {
 2216|     92|        let path = dir.join(name);
 2217|     92|        let mut file = File::create(path)?;
                                                       ^0
 2218|     92|        write!(file, "{}", content)?;
                                                 ^0
 2219|     92|        Ok(())
 2220|     92|    }
 2221|       |
 2222|       |    #[test]
 2223|      1|    fn test_count_lines_with_stats_special_cases() -> io::Result<()> {
 2224|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2225|      1|        create_test_file(
 2226|      1|            temp_dir.path(),
 2227|      1|            "Dockerfile.prod",
 2228|      1|            "FROM alpine\n# comment\n",
 2229|      1|        )?;
                       ^0
 2230|      1|        create_test_file(temp_dir.path(), "Makefile", "all:\n\t@echo \\\"done\\\"\n")?;
                                                                                                   ^0
 2231|      1|        create_test_file(
 2232|      1|            temp_dir.path(),
 2233|      1|            "CMakeLists.txt",
 2234|      1|            "cmake_minimum_required(VERSION 3.25)\n# note\n",
 2235|      1|        )?;
                       ^0
 2236|      1|        create_test_file(temp_dir.path(), "unknown.xyz", "plain text line\n")?;
                                                                                           ^0
 2237|       |
 2238|      1|        let (docker_stats, docker_total) =
 2239|      1|            count_lines_with_stats(&temp_dir.path().join("Dockerfile.prod"))?;
                                                                                          ^0
 2240|      1|        assert_eq!(docker_total, 2);
 2241|      1|        assert!(docker_stats.comment_lines >= 1);
 2242|       |
 2243|      1|        let (make_stats, _) = count_lines_with_stats(&temp_dir.path().join("Makefile"))?;
                                                                                                     ^0
 2244|      1|        assert!(make_stats.code_lines >= 1);
 2245|       |
 2246|      1|        let (cmake_stats, _) = count_lines_with_stats(&temp_dir.path().join("CMakeLists.txt"))?;
                                                                                                            ^0
 2247|      1|        assert!(cmake_stats.comment_lines >= 1);
 2248|       |
 2249|      1|        let (unknown_stats, _) = count_lines_with_stats(&temp_dir.path().join("unknown.xyz"))?;
                                                                                                           ^0
 2250|      1|        assert!(unknown_stats.code_lines >= 1);
 2251|      1|        Ok(())
 2252|      1|    }
 2253|       |
 2254|       |    struct CaptureWriter {
 2255|       |        buffer: Arc<Mutex<Vec<u8>>>,
 2256|       |    }
 2257|       |
 2258|       |    impl CaptureWriter {
 2259|      1|        fn new(buffer: Arc<Mutex<Vec<u8>>>) -> Self {
 2260|      1|            Self { buffer }
 2261|      1|        }
 2262|       |
 2263|      1|        fn into_string(buffer: Arc<Mutex<Vec<u8>>>) -> String {
 2264|      1|            let data = buffer.lock().expect("lock poisoned").clone();
 2265|      1|            String::from_utf8_lossy(&data).into_owned()
 2266|      1|        }
 2267|       |    }
 2268|       |
 2269|       |    #[test]
 2270|      1|    fn test_performance_metrics_custom_writer() {
 2271|      1|        let buffer = Arc::new(Mutex::new(Vec::new()));
 2272|      1|        let writer = CaptureWriter::new(buffer.clone());
 2273|      1|        let mut metrics = PerformanceMetrics::with_writer(Box::new(writer), true);
 2274|      1|        metrics.last_update = metrics.start_time - Duration::from_secs(2);
 2275|      1|        metrics.update(10);
 2276|      1|        metrics.print_final_stats();
 2277|      1|        let output = CaptureWriter::into_string(buffer);
 2278|      1|        assert!(output.contains("Processed"));
 2279|      1|        assert!(output.contains("Performance Summary"));
 2280|      1|    }
 2281|       |
 2282|       |    impl Write for CaptureWriter {
 2283|     29|        fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
 2284|     29|            let mut guard = self.buffer.lock().expect("lock poisoned");
 2285|     29|            guard.extend_from_slice(buf);
 2286|     29|            Ok(buf.len())
 2287|     29|        }
 2288|       |
 2289|      1|        fn flush(&mut self) -> io::Result<()> {
 2290|      1|            Ok(())
 2291|      1|        }
 2292|       |    }
 2293|       |
 2294|       |    #[test]
 2295|      1|    fn test_safe_rate_handles_zero_elapsed() {
 2296|      1|        assert_eq!(safe_rate(100, 0.0), 0.0);
 2297|      1|    }
 2298|       |
 2299|       |    #[test]
 2300|      1|    fn test_safe_rate_precision() {
 2301|      1|        let rate = safe_rate(4850468, 10.0);
 2302|      1|        assert!((rate - 485046.8).abs() < 1e-6);
 2303|      1|    }
 2304|       |
 2305|       |    #[test]
 2306|      1|    fn test_safe_percentage_handles_zero_denominator() {
 2307|      1|        assert_eq!(safe_percentage(42, 0), 0.0);
 2308|      1|    }
 2309|       |
 2310|       |    #[test]
 2311|      1|    fn test_safe_percentage_precision() {
 2312|      1|        let pct = safe_percentage(375, 1000);
 2313|      1|        assert!((pct - 37.5).abs() < 1e-6);
 2314|      1|    }
 2315|       |
 2316|       |    #[test]
 2317|      1|    fn test_normalize_stats_eliminates_overlap() {
 2318|      1|        let stats = LanguageStats {
 2319|      1|            code_lines: 2,
 2320|      1|            comment_lines: 2,
 2321|      1|            blank_lines: 0,
 2322|      1|            overlap_lines: 0,
 2323|      1|        };
 2324|      1|        let normalized = normalize_stats(stats, 3);
 2325|      1|        assert_eq!(
 2326|      1|            normalized.code_lines + normalized.comment_lines + normalized.blank_lines
 2327|      1|                - normalized.overlap_lines,
 2328|      1|            3
 2329|      1|        );
 2330|      1|        assert_eq!(normalized.comment_lines, stats.comment_lines);
 2331|      1|        assert_eq!(normalized.overlap_lines, 1);
 2332|      1|    }
 2333|       |
 2334|       |    #[test]
 2335|      1|    fn test_normalize_stats_does_not_inflate_when_zero_sum() {
 2336|      1|        let stats = LanguageStats {
 2337|      1|            code_lines: 0,
 2338|      1|            comment_lines: 0,
 2339|      1|            blank_lines: 0,
 2340|      1|            overlap_lines: 0,
 2341|      1|        };
 2342|      1|        let normalized = normalize_stats(stats, 5);
 2343|      1|        assert_eq!(normalized.code_lines, 0);
 2344|      1|        assert_eq!(normalized.comment_lines, 0);
 2345|      1|        assert_eq!(normalized.blank_lines, 0);
 2346|      1|        assert_eq!(normalized.overlap_lines, 0);
 2347|      1|    }
 2348|       |
 2349|       |    #[test]
 2350|      1|    fn test_directory_scanning() -> io::Result<()> {
 2351|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2352|      1|        let args = test_args();
 2353|      1|        let mut metrics = test_metrics();
 2354|      1|        let sub_dir = temp_dir.path().join("subdir");
 2355|      1|        fs::create_dir(&sub_dir)?;
                                              ^0
 2356|      1|        create_test_file(
 2357|      1|            temp_dir.path(),
 2358|      1|            "main.rs",
 2359|      1|            "fn main() {\n// Comment\nprintln!(\"Hello\");\n}\n",
 2360|      1|        )?;
                       ^0
 2361|      1|        create_test_file(
 2362|      1|            &sub_dir,
 2363|      1|            "lib.rs",
 2364|      1|            "pub fn add(a: i32, b: i32) -> i32 {\n/* Block comment */\na + b\n}\n",
 2365|      1|        )?;
                       ^0
 2366|      1|        create_test_file(temp_dir.path(), "readme.md", "# Test Project")?;
                                                                                      ^0
 2367|      1|        let mut error_count = 0;
 2368|      1|        let mut entries_count = 0usize;
 2369|      1|        let stats = scan_directory(
 2370|      1|            temp_dir.path(),
 2371|      1|            &args,
 2372|      1|            temp_dir.path(),
 2373|      1|            &mut metrics,
 2374|      1|            0,
 2375|      1|            &mut entries_count,
 2376|      1|            &mut error_count,
 2377|      1|        )?;
                       ^0
 2378|      1|        let root_canon = fs::canonicalize(temp_dir.path())?;
                                                                        ^0
 2379|      1|        let main_stats = stats
 2380|      1|            .get(&root_canon)
 2381|      1|            .or_else(|| stats.get(temp_dir.path()))
                                      ^0
 2382|      1|            .unwrap();
 2383|      1|        let main_rust_stats = main_stats.language_stats.get("Rust").unwrap();
 2384|      1|        assert_eq!(main_rust_stats.0, 1);
 2385|      1|        assert_eq!(main_rust_stats.1.code_lines, 3);
 2386|      1|        assert_eq!(main_rust_stats.1.comment_lines, 1);
 2387|      1|        let sub_canon = fs::canonicalize(&sub_dir)?;
                                                                ^0
 2388|      1|        let sub_stats = stats
 2389|      1|            .get(&sub_canon)
 2390|      1|            .or_else(|| stats.get(&sub_dir))
                                      ^0
 2391|      1|            .unwrap();
 2392|      1|        let sub_rust_stats = sub_stats.language_stats.get("Rust").unwrap();
 2393|      1|        assert_eq!(sub_rust_stats.0, 1);
 2394|      1|        assert_eq!(sub_rust_stats.1.code_lines, 3);
 2395|      1|        assert_eq!(sub_rust_stats.1.comment_lines, 1);
 2396|      1|        Ok(())
 2397|      1|    }
 2398|       |
 2399|       |    #[test]
 2400|      1|    fn test_scan_directory_respects_ignore_list() -> io::Result<()> {
 2401|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2402|      1|        let root = temp_dir.path();
 2403|      1|        let target_dir = root.join("target");
 2404|      1|        fs::create_dir(&target_dir)?;
                                                 ^0
 2405|      1|        create_test_file(&target_dir, "skip.rs", "fn skipped() {}\n")?;
                                                                                   ^0
 2406|      1|        create_test_file(root, "main.rs", "fn main() {}\n")?;
                                                                         ^0
 2407|       |
 2408|      1|        let mut args = test_args();
 2409|      1|        args.ignore = vec!["target".to_string()];
 2410|      1|
 2411|      1|        let mut metrics = test_metrics();
 2412|      1|
 2413|      1|        let mut entries_count = 0usize;
 2414|      1|        let mut error_count = 0usize;
 2415|      1|        let stats = scan_directory(
 2416|      1|            root,
 2417|      1|            &args,
 2418|      1|            root,
 2419|      1|            &mut metrics,
 2420|      1|            0,
 2421|      1|            &mut entries_count,
 2422|      1|            &mut error_count,
 2423|      1|        )?;
                       ^0
 2424|      1|        assert_eq!(error_count, 0);
 2425|       |
 2426|      1|        let target_canon = fs::canonicalize(&target_dir)?;
                                                                      ^0
 2427|      1|        assert!(
 2428|      1|            !stats.contains_key(&target_canon),
 2429|      0|            "ignored directory should not appear in stats"
 2430|       |        );
 2431|       |
 2432|      1|        let root_canon = fs::canonicalize(root)?;
                                                             ^0
 2433|      1|        let root_stats = stats
 2434|      1|            .get(&root_canon)
 2435|      1|            .expect("root stats should exist after scanning");
 2436|      1|        let rust_entry = root_stats
 2437|      1|            .language_stats
 2438|      1|            .get("Rust")
 2439|      1|            .expect("Rust stats should be present");
 2440|      1|        assert_eq!(rust_entry.0, 1);
 2441|      1|        assert_eq!(rust_entry.1.code_lines, 1);
 2442|      1|        Ok(())
 2443|      1|    }
 2444|       |
 2445|       |    #[test]
 2446|      1|    fn test_rust_line_counting() -> io::Result<()> {
 2447|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2448|      1|        create_test_file(temp_dir.path(), "test.rs", "fn main() {\n// Line comment\n/* Block comment */\n/// Doc comment\n//! Module comment\nprintln!(\"Hello\");\n}\n")?;
                                                                                                                                                                                       ^0
 2449|      1|        let (stats, _total_lines) = count_rust_lines(temp_dir.path().join("test.rs").as_path())?;
                                                                                                             ^0
 2450|      1|        assert_eq!(stats.code_lines, 3);
 2451|      1|        assert_eq!(stats.comment_lines, 4);
 2452|      1|        assert_eq!(stats.blank_lines, 0);
 2453|      1|        Ok(())
 2454|      1|    }
 2455|       |
 2456|       |    #[test]
 2457|      1|    fn test_rust_block_comment_trailing_code() -> io::Result<()> {
 2458|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2459|      1|        create_test_file(
 2460|      1|            temp_dir.path(),
 2461|      1|            "trail.rs",
 2462|      1|            "fn main() {\nlet value = 1; /* comment */ println!(\"{}\", value);\n}\n",
 2463|      1|        )?;
                       ^0
 2464|      1|        let (stats, _total_lines) = count_rust_lines(temp_dir.path().join("trail.rs").as_path())?;
                                                                                                              ^0
 2465|      1|        assert_eq!(stats.code_lines, 4);
 2466|      1|        assert_eq!(stats.comment_lines, 1);
 2467|      1|        Ok(())
 2468|      1|    }
 2469|       |
 2470|       |    #[test]
 2471|      1|    fn test_python_line_counting() -> io::Result<()> {
 2472|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2473|      1|        create_test_file(
 2474|      1|            temp_dir.path(),
 2475|      1|            "test.py",
 2476|      1|            "def main():\n# Line comment\n'''Block\ncomment'''\nprint('Hello')\n\n",
 2477|      1|        )?;
                       ^0
 2478|      1|        let (stats, _total_lines) = count_python_lines(temp_dir.path().join("test.py").as_path())?;
                                                                                                               ^0
 2479|      1|        assert_eq!(stats.code_lines, 2);
 2480|      1|        assert_eq!(stats.comment_lines, 3);
 2481|      1|        assert_eq!(stats.blank_lines, 1);
 2482|      1|        Ok(())
 2483|      1|    }
 2484|       |
 2485|       |    #[test]
 2486|      1|    fn test_python_triple_double_quote() -> io::Result<()> {
 2487|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2488|      1|        create_test_file(
 2489|      1|            temp_dir.path(),
 2490|      1|            "test_ddq.py",
 2491|      1|            "def main():\n\"\"\"Block\ncomment\"\"\"\nprint('Hello')\n",
 2492|      1|        )?;
                       ^0
 2493|      1|        let (stats, _total_lines) =
 2494|      1|            count_python_lines(temp_dir.path().join("test_ddq.py").as_path())?;
                                                                                           ^0
 2495|      1|        assert_eq!(stats.code_lines, 2);
 2496|      1|        assert_eq!(stats.comment_lines, 2);
 2497|      1|        Ok(())
 2498|      1|    }
 2499|       |
 2500|       |    #[test]
 2501|      1|    fn test_python_triple_quotes_and_continuation() -> io::Result<()> {
 2502|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2503|      1|        create_test_file(
 2504|      1|            temp_dir.path(),
 2505|      1|            "mixed.py",
 2506|      1|            "def doc():\n\"\"\"Doc\"\"\" # inline\nvalue = \"hello\" \\\n# comment on continuation\n'''Inline''' print('done')\n",
 2507|      1|        )?;
                       ^0
 2508|      1|        let (stats, _total_lines) = count_python_lines(temp_dir.path().join("mixed.py").as_path())?;
                                                                                                                ^0
 2509|      1|        assert!(stats.code_lines >= 2);
 2510|      1|        assert!(stats.comment_lines >= 2);
 2511|      1|        Ok(())
 2512|      1|    }
 2513|       |
 2514|       |    #[test]
 2515|      1|    fn test_javascript_line_counting() -> io::Result<()> {
 2516|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2517|      1|        create_test_file(temp_dir.path(), "test.js", "function main() {\n// Line comment\n/* Block comment */\n/* Multi-line\ncomment */\n<!-- JSX comment -->\nconsole.log('Hello');\n}\n")?;
                                                                                                                                                                                                          ^0
 2518|      1|        let (stats, _total_lines) =
 2519|      1|            count_javascript_lines(temp_dir.path().join("test.js").as_path())?;
                                                                                           ^0
 2520|      1|        assert_eq!(stats.code_lines, 3);
 2521|      1|        assert_eq!(stats.comment_lines, 5);
 2522|      1|        assert_eq!(stats.blank_lines, 0);
 2523|      1|        Ok(())
 2524|      1|    }
 2525|       |
 2526|       |    #[test]
 2527|      1|    fn test_javascript_jsx_comment_transition() -> io::Result<()> {
 2528|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2529|      1|        create_test_file(
 2530|      1|            temp_dir.path(),
 2531|      1|            "jsx.js",
 2532|      1|            "const markup = '<div>';\n<!-- jsx\ncomment --> <span>done</span>\nlet value = 1; /* block */ console.log(value);\n/* open\ncomment */\nconsole.log('after');\n",
 2533|      1|        )?;
                       ^0
 2534|      1|        let (stats, _total_lines) =
 2535|      1|            count_javascript_lines(temp_dir.path().join("jsx.js").as_path())?;
                                                                                          ^0
 2536|      1|        assert!(stats.code_lines >= 3);
 2537|      1|        assert!(stats.comment_lines >= 4);
 2538|      1|        Ok(())
 2539|      1|    }
 2540|       |
 2541|       |    #[test]
 2542|      1|    fn test_perl_line_counting() -> io::Result<()> {
 2543|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2544|      1|        create_test_file(temp_dir.path(), "test.pl", "#!/usr/bin/perl\n# Line comment\n=pod\nDocumentation block\n=cut\nprint \"Hello\";\n\n")?;
                                                                                                                                                            ^0
 2545|      1|        let (stats, _total_lines) = count_perl_lines(temp_dir.path().join("test.pl").as_path())?;
                                                                                                             ^0
 2546|      1|        assert_eq!(stats.code_lines, 2);
 2547|      1|        assert_eq!(stats.comment_lines, 4);
 2548|      1|        assert_eq!(stats.blank_lines, 1);
 2549|      1|        Ok(())
 2550|      1|    }
 2551|       |
 2552|       |    #[test]
 2553|      1|    fn test_ruby_line_counting() -> io::Result<()> {
 2554|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2555|      1|        create_test_file(temp_dir.path(), "test.rb", "#!/usr/bin/env ruby\n# This is a comment\nputs 'Hello, world!'\n=begin\nThis is a block comment\n=end\nputs 'Goodbye'\n")?;
                                                                                                                                                                                             ^0
 2556|      1|        let (stats, _total_lines) = count_ruby_lines(temp_dir.path().join("test.rb").as_path())?;
                                                                                                             ^0
 2557|      1|        assert_eq!(stats.code_lines, 3);
 2558|      1|        assert_eq!(stats.comment_lines, 4);
 2559|      1|        Ok(())
 2560|      1|    }
 2561|       |
 2562|       |    #[test]
 2563|      1|    fn test_shell_line_counting() -> io::Result<()> {
 2564|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2565|      1|        create_test_file(
 2566|      1|            temp_dir.path(),
 2567|      1|            "test.sh",
 2568|      1|            "#!/bin/bash\n# This is a comment\necho \"Hello, world!\"\n",
 2569|      1|        )?;
                       ^0
 2570|      1|        let (stats, _total_lines) = count_shell_lines(temp_dir.path().join("test.sh").as_path())?;
                                                                                                              ^0
 2571|      1|        assert_eq!(stats.code_lines, 2);
 2572|      1|        assert_eq!(stats.comment_lines, 1);
 2573|      1|        Ok(())
 2574|      1|    }
 2575|       |
 2576|       |    #[test]
 2577|      1|    fn test_pascal_line_counting() -> io::Result<()> {
 2578|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2579|      1|        create_test_file(temp_dir.path(), "test.pas", "program Test;\n// This is a line comment\n{ This is a block comment }\nwriteln('Hello, world!');\n(* Another block comment\nspanning multiple lines *)\nwriteln('Goodbye');\n")?;
                                                                                                                                                                                                                                                    ^0
 2580|      1|        let (stats, _total_lines) = count_pascal_lines(temp_dir.path().join("test.pas").as_path())?;
                                                                                                                ^0
 2581|      1|        assert_eq!(stats.code_lines, 3);
 2582|      1|        assert_eq!(stats.comment_lines, 4);
 2583|      1|        Ok(())
 2584|      1|    }
 2585|       |
 2586|       |    #[test]
 2587|      1|    fn test_pascal_mixed_comment_styles_single_line() -> io::Result<()> {
 2588|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2589|      1|        create_test_file(
 2590|      1|            temp_dir.path(),
 2591|      1|            "mixed.pas",
 2592|      1|            "{ block } writeln('a');\n(* another *) writeln('b'); // trailing\n",
 2593|      1|        )?;
                       ^0
 2594|      1|        let (stats, _total_lines) =
 2595|      1|            count_pascal_lines(temp_dir.path().join("mixed.pas").as_path())?;
                                                                                         ^0
 2596|      1|        assert!(stats.code_lines >= 2);
 2597|      1|        assert!(stats.comment_lines >= 2);
 2598|      1|        Ok(())
 2599|      1|    }
 2600|       |
 2601|       |    // --- New Tests ---
 2602|       |
 2603|       |    #[test]
 2604|      1|    fn test_case_insensitive_extension() {
 2605|      1|        // Test that uppercase or mixed-case extensions are correctly recognized.
 2606|      1|        assert_eq!(get_language_from_extension("TEST.RS"), Some("Rust"));
 2607|      1|        assert_eq!(
 2608|      1|            get_language_from_extension("example.Js"),
 2609|      1|            Some("JavaScript")
 2610|      1|        );
 2611|      1|        assert_eq!(get_language_from_extension("module.Py"), Some("Python"));
 2612|      1|        assert_eq!(get_language_from_extension("FOO.TS"), Some("TypeScript"));
 2613|      1|    }
 2614|       |
 2615|       |    #[test]
 2616|      1|    fn test_dotfile_language_detection() {
 2617|      1|        assert_eq!(get_language_from_extension(".bashrc"), Some("Shell"));
 2618|      1|        assert_eq!(get_language_from_extension(".zprofile"), Some("Shell"));
 2619|      1|        assert_eq!(
 2620|      1|            get_language_from_extension("Dockerfile.prod"),
 2621|      1|            Some("Dockerfile")
 2622|      1|        );
 2623|      1|        assert_eq!(get_language_from_extension("CMakeLists.txt"), Some("CMake"));
 2624|      1|    }
 2625|       |
 2626|       |    #[test]
 2627|      1|    fn test_invalid_utf8_handling() -> io::Result<()> {
 2628|       |        // Create a file with invalid UTF-8 bytes.
 2629|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2630|      1|        let file_path = temp_dir.path().join("invalid.txt");
 2631|      1|        // Write valid UTF-8 text, then an invalid byte (0xFF), then more valid text.
 2632|      1|        fs::write(&file_path, b"hello\n\xFFworld\n")?;
                                                                  ^0
 2633|       |        // read_file_lines_lossy should not error and should replace the invalid byte.
 2634|      1|        let lines: Vec<String> =
 2635|      1|            read_file_lines_lossy(&file_path)?.collect::<Result<Vec<_>, io::Error>>()?;
                                                           ^0                                      ^0
 2636|       |        // Expect two lines: "hello" and "�world"
 2637|      1|        assert_eq!(lines.len(), 2);
 2638|      1|        assert_eq!(lines[0], "hello");
 2639|       |        // The invalid byte is replaced with the Unicode replacement character.
 2640|      1|        assert!(lines[1].contains("�world"));
 2641|      1|        Ok(())
 2642|      1|    }
 2643|       |
 2644|       |    #[test]
 2645|      1|    fn test_generic_line_counting() -> io::Result<()> {
 2646|       |        // Create a file with an unknown extension containing blank and code lines.
 2647|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2648|       |        // Mix of code lines and blank lines
 2649|      1|        let content = "first line\n\nsecond line\n   \nthird line\n";
 2650|      1|        create_test_file(temp_dir.path(), "file.xyz", content)?;
                                                                            ^0
 2651|       |
 2652|      1|        let (stats, _total_lines) =
 2653|      1|            count_generic_lines(temp_dir.path().join("file.xyz").as_path())?;
                                                                                         ^0
 2654|      1|        assert_eq!(stats.code_lines, 3);
 2655|      1|        assert_eq!(stats.blank_lines, 2);
 2656|       |        // Generic counting does not track comment lines
 2657|      1|        assert_eq!(stats.comment_lines, 0);
 2658|      1|        Ok(())
 2659|      1|    }
 2660|       |
 2661|       |    #[test]
 2662|      1|    fn test_truncate_start() {
 2663|      1|        // When the string is short, it remains unchanged.
 2664|      1|        assert_eq!(truncate_start("short", DIR_WIDTH), "short");
 2665|       |        // When too long, it should be truncated from the start.
 2666|      1|        let long_str = "winmerge-master\\Externals\\boost\\boost\\config\\compiler";
 2667|      1|        let truncated = truncate_start(long_str, DIR_WIDTH);
 2668|      1|        assert_eq!(truncated.chars().count(), DIR_WIDTH);
 2669|      1|        assert!(truncated.starts_with("..."));
 2670|       |        // The truncated version should contain the important ending portion.
 2671|      1|        let expected_ending: String = long_str
 2672|      1|            .chars()
 2673|      1|            .rev()
 2674|      1|            .take(DIR_WIDTH - 3)
 2675|      1|            .collect::<Vec<_>>()
 2676|      1|            .into_iter()
 2677|      1|            .rev()
 2678|      1|            .collect();
 2679|      1|        assert!(truncated.ends_with(&expected_ending));
 2680|      1|    }
 2681|       |
 2682|       |    #[test]
 2683|      1|    fn test_yaml_line_counting() -> io::Result<()> {
 2684|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2685|      1|        create_test_file(
 2686|      1|            temp_dir.path(),
 2687|      1|            "test.yaml",
 2688|      1|            "# comment\nkey: value\n\nlist:\n  - item # inline text after value (treated as code)\n",
 2689|      1|        )?;
                       ^0
 2690|      1|        let (stats, _total_lines) = count_yaml_lines(temp_dir.path().join("test.yaml").as_path())?;
                                                                                                               ^0
 2691|      1|        assert_eq!(stats.code_lines, 3); // key, list:, item
 2692|      1|        assert_eq!(stats.comment_lines, 1);
 2693|      1|        assert_eq!(stats.blank_lines, 1);
 2694|      1|        Ok(())
 2695|      1|    }
 2696|       |
 2697|       |    #[test]
 2698|      1|    fn test_toml_line_counting() -> io::Result<()> {
 2699|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2700|      1|        create_test_file(
 2701|      1|            temp_dir.path(),
 2702|      1|            "Cargo.toml",
 2703|      1|            "# comment\n[package]\nname = 'demo'\n\n[dependencies]\n",
 2704|      1|        )?;
                       ^0
 2705|      1|        let (stats, _total_lines) = count_toml_lines(temp_dir.path().join("Cargo.toml").as_path())?;
                                                                                                                ^0
 2706|      1|        assert_eq!(stats.code_lines, 3);
 2707|      1|        assert_eq!(stats.comment_lines, 1);
 2708|      1|        assert_eq!(stats.blank_lines, 1);
 2709|      1|        Ok(())
 2710|      1|    }
 2711|       |
 2712|       |    #[test]
 2713|      1|    fn test_json_line_counting() -> io::Result<()> {
 2714|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2715|      1|        create_test_file(
 2716|      1|            temp_dir.path(),
 2717|      1|            "data.json",
 2718|      1|            "{\n  \"k\": 1,\n  \"arr\": [1,2]\n}\n\n",
 2719|      1|        )?;
                       ^0
 2720|      1|        let (stats, _total_lines) = count_json_lines(temp_dir.path().join("data.json").as_path())?;
                                                                                                               ^0
 2721|      1|        assert_eq!(stats.code_lines, 4);
 2722|      1|        assert_eq!(stats.comment_lines, 0);
 2723|      1|        assert_eq!(stats.blank_lines, 1);
 2724|      1|        Ok(())
 2725|      1|    }
 2726|       |
 2727|       |    #[test]
 2728|      1|    fn test_xml_line_counting() -> io::Result<()> {
 2729|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2730|      1|        create_test_file(
 2731|      1|            temp_dir.path(),
 2732|      1|            "data.xml",
 2733|      1|            "<root>\n<!-- c1 -->\n<!--\n block\n-->\n<child/>\n</root>\n",
 2734|      1|        )?;
                       ^0
 2735|      1|        let (stats, _total_lines) =
 2736|      1|            count_xml_like_lines(temp_dir.path().join("data.xml").as_path())?;
                                                                                          ^0
 2737|      1|        assert!(stats.code_lines >= 3);
 2738|      1|        assert!(stats.comment_lines >= 2);
 2739|      1|        assert_eq!(stats.blank_lines, 0);
 2740|      1|        Ok(())
 2741|      1|    }
 2742|       |
 2743|       |    #[test]
 2744|      1|    fn test_html_line_counting() -> io::Result<()> {
 2745|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2746|      1|        create_test_file(
 2747|      1|            temp_dir.path(),
 2748|      1|            "index.html",
 2749|      1|            "<html>\n<body>\n<!-- banner -->\n<div>hi</div>\n<!--\n multi\n-->\n</body>\n</html>\n",
 2750|      1|        )?;
                       ^0
 2751|      1|        let (stats, _total_lines) =
 2752|      1|            count_xml_like_lines(temp_dir.path().join("index.html").as_path())?;
                                                                                            ^0
 2753|      1|        assert!(stats.code_lines >= 5); // <html>, <body>, <div>, </body>, </html>
 2754|      1|        assert!(stats.comment_lines >= 2);
 2755|      1|        Ok(())
 2756|      1|    }
 2757|       |
 2758|       |    #[test]
 2759|      1|    fn test_makefile_line_counting() -> io::Result<()> {
 2760|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2761|      1|        create_test_file(
 2762|      1|            temp_dir.path(),
 2763|      1|            "Makefile",
 2764|      1|            "# comment\n\nall:\n\t@echo hello # inline\n",
 2765|      1|        )?;
                       ^0
 2766|      1|        let (stats, _total_lines) =
 2767|      1|            count_makefile_lines(temp_dir.path().join("Makefile").as_path())?;
                                                                                          ^0
 2768|      1|        assert_eq!(stats.code_lines, 2); // all:, recipe line
 2769|      1|        assert_eq!(stats.comment_lines, 1);
 2770|      1|        assert_eq!(stats.blank_lines, 1);
 2771|      1|        Ok(())
 2772|      1|    }
 2773|       |
 2774|       |    #[test]
 2775|      1|    fn test_makefile_extension_mapping() {
 2776|      1|        assert_eq!(get_language_from_extension("rules.mk"), Some("Makefile"));
 2777|      1|        assert_eq!(get_language_from_extension("GNUmakefile"), Some("Makefile"));
 2778|      1|    }
 2779|       |
 2780|       |    #[test]
 2781|      1|    fn test_dockerfile_line_counting() -> io::Result<()> {
 2782|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2783|      1|        create_test_file(
 2784|      1|            temp_dir.path(),
 2785|      1|            "Dockerfile",
 2786|      1|            "# comment\nFROM alpine\nRUN echo hi\n",
 2787|      1|        )?;
                       ^0
 2788|      1|        let (stats, _total_lines) =
 2789|      1|            count_dockerfile_lines(temp_dir.path().join("Dockerfile").as_path())?;
                                                                                              ^0
 2790|      1|        assert_eq!(stats.code_lines, 2);
 2791|      1|        assert_eq!(stats.comment_lines, 1);
 2792|      1|        Ok(())
 2793|      1|    }
 2794|       |
 2795|       |    #[test]
 2796|      1|    fn test_ini_line_counting() -> io::Result<()> {
 2797|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2798|      1|        create_test_file(
 2799|      1|            temp_dir.path(),
 2800|      1|            "config.ini",
 2801|      1|            "; top comment\n# another\n[core]\nname = demo\n\n",
 2802|      1|        )?;
                       ^0
 2803|      1|        let (stats, _total_lines) = count_ini_lines(temp_dir.path().join("config.ini").as_path())?;
                                                                                                               ^0
 2804|      1|        assert_eq!(stats.code_lines, 2);
 2805|      1|        assert_eq!(stats.comment_lines, 2);
 2806|      1|        assert_eq!(stats.blank_lines, 1);
 2807|      1|        Ok(())
 2808|      1|    }
 2809|       |
 2810|       |    #[test]
 2811|      1|    fn test_hcl_line_counting() -> io::Result<()> {
 2812|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2813|      1|        create_test_file(
 2814|      1|            temp_dir.path(),
 2815|      1|            "main.tf",
 2816|      1|            "# comment\n// also comment\nresource \"x\" \"y\" {\n  a = 1 /* inline */\n}\n/*\nblock\n*/\n",
 2817|      1|        )?;
                       ^0
 2818|      1|        let (stats, _total_lines) = count_hcl_lines(temp_dir.path().join("main.tf").as_path())?;
                                                                                                            ^0
 2819|      1|        assert!(stats.code_lines >= 3);
 2820|      1|        assert!(stats.comment_lines >= 4);
 2821|      1|        Ok(())
 2822|      1|    }
 2823|       |
 2824|       |    #[test]
 2825|      1|    fn test_cmake_line_counting() -> io::Result<()> {
 2826|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2827|      1|        create_test_file(
 2828|      1|            temp_dir.path(),
 2829|      1|            "CMakeLists.txt",
 2830|      1|            "# top\ncmake_minimum_required(VERSION 3.25)\nproject(demo)\n# end\n",
 2831|      1|        )?;
                       ^0
 2832|      1|        let (stats, _total_lines) =
 2833|      1|            count_cmake_lines(temp_dir.path().join("CMakeLists.txt").as_path())?;
                                                                                             ^0
 2834|      1|        assert_eq!(stats.code_lines, 2);
 2835|      1|        assert_eq!(stats.comment_lines, 2);
 2836|      1|        Ok(())
 2837|      1|    }
 2838|       |
 2839|       |    #[test]
 2840|      1|    fn test_powershell_line_counting() -> io::Result<()> {
 2841|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2842|      1|        create_test_file(
 2843|      1|            temp_dir.path(),
 2844|      1|            "script.ps1",
 2845|      1|            "# line\nWrite-Host 'hi'\n<# block\ncomment #> Write-Host 'after'\n",
 2846|      1|        )?;
                       ^0
 2847|      1|        let (stats, _total_lines) =
 2848|      1|            count_powershell_lines(temp_dir.path().join("script.ps1").as_path())?;
                                                                                              ^0
 2849|      1|        assert!(stats.code_lines >= 2);
 2850|      1|        assert!(stats.comment_lines >= 2);
 2851|      1|        Ok(())
 2852|      1|    }
 2853|       |
 2854|       |    #[test]
 2855|      1|    fn test_powershell_block_comment_then_line_comment() -> io::Result<()> {
 2856|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2857|      1|        create_test_file(
 2858|      1|            temp_dir.path(),
 2859|      1|            "mixed.ps1",
 2860|      1|            "Write-Host 1 <# inline #> # trailing\n<# block\ncontinues\n#>\nWrite-Host 2\n",
 2861|      1|        )?;
                       ^0
 2862|      1|        let (stats, _total_lines) =
 2863|      1|            count_powershell_lines(temp_dir.path().join("mixed.ps1").as_path())?;
                                                                                             ^0
 2864|      1|        assert!(stats.code_lines >= 2);
 2865|      1|        assert!(stats.comment_lines >= 2);
 2866|      1|        Ok(())
 2867|      1|    }
 2868|       |
 2869|       |    #[test]
 2870|      1|    fn test_batch_line_counting() -> io::Result<()> {
 2871|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2872|      1|        create_test_file(
 2873|      1|            temp_dir.path(),
 2874|      1|            "run.bat",
 2875|      1|            "REM header\n:: also comment\n@echo on\nset X=1\n",
 2876|      1|        )?;
                       ^0
 2877|      1|        let (stats, _total_lines) = count_batch_lines(temp_dir.path().join("run.bat").as_path())?;
                                                                                                              ^0
 2878|      1|        assert_eq!(stats.comment_lines, 2);
 2879|      1|        assert_eq!(stats.code_lines, 2);
 2880|      1|        Ok(())
 2881|      1|    }
 2882|       |
 2883|       |    #[test]
 2884|      1|    fn test_tcl_line_counting() -> io::Result<()> {
 2885|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2886|      1|        create_test_file(
 2887|      1|            temp_dir.path(),
 2888|      1|            "prog.tcl",
 2889|      1|            "#! /usr/bin/env tclsh\n# comment\nputs \"hello\"\n",
 2890|      1|        )?;
                       ^0
 2891|      1|        let (stats, _total_lines) = count_tcl_lines(temp_dir.path().join("prog.tcl").as_path())?;
                                                                                                             ^0
 2892|      1|        assert_eq!(stats.code_lines, 2); // shebang + puts
 2893|      1|        assert_eq!(stats.comment_lines, 1);
 2894|      1|        Ok(())
 2895|      1|    }
 2896|       |
 2897|       |    #[test]
 2898|      1|    fn test_rst_line_counting() -> io::Result<()> {
 2899|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2900|      1|        create_test_file(
 2901|      1|            temp_dir.path(),
 2902|      1|            "doc.rst",
 2903|      1|            "Title\n=====\n\n.. comment\n\nParagraph text.\n",
 2904|      1|        )?;
                       ^0
 2905|      1|        let (stats, _total_lines) = count_rst_lines(temp_dir.path().join("doc.rst").as_path())?;
                                                                                                            ^0
 2906|      1|        assert_eq!(stats.blank_lines, 2);
 2907|      1|        assert_eq!(stats.comment_lines, 0);
 2908|      1|        assert_eq!(stats.code_lines, 4);
 2909|      1|        Ok(())
 2910|      1|    }
 2911|       |
 2912|       |    #[test]
 2913|      1|    fn test_velocity_line_counting() -> io::Result<()> {
 2914|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2915|      1|        create_test_file(
 2916|      1|            temp_dir.path(),
 2917|      1|            "template.vm",
 2918|      1|            "## line comment\nHello #* block *# World\n#* multi\nline *#\n",
 2919|      1|        )?;
                       ^0
 2920|      1|        let (stats, _total_lines) =
 2921|      1|            count_velocity_lines(temp_dir.path().join("template.vm").as_path())?;
                                                                                             ^0
 2922|      1|        assert!(stats.code_lines >= 2);
 2923|      1|        assert!(stats.comment_lines >= 2);
 2924|      1|        Ok(())
 2925|      1|    }
 2926|       |
 2927|       |    #[test]
 2928|      1|    fn test_mustache_line_counting() -> io::Result<()> {
 2929|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2930|      1|        create_test_file(
 2931|      1|            temp_dir.path(),
 2932|      1|            "view.mustache",
 2933|      1|            "{{! top }}\nHello {{name}}\n{{! multi\n line }}\n",
 2934|      1|        )?;
                       ^0
 2935|      1|        let (stats, _total_lines) =
 2936|      1|            count_mustache_lines(temp_dir.path().join("view.mustache").as_path())?;
                                                                                               ^0
 2937|      1|        assert!(stats.code_lines >= 1);
 2938|      1|        assert!(stats.comment_lines >= 2);
 2939|      1|        Ok(())
 2940|      1|    }
 2941|       |
 2942|       |    #[test]
 2943|      1|    fn test_proto_line_counting() -> io::Result<()> {
 2944|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2945|      1|        create_test_file(
 2946|      1|            temp_dir.path(),
 2947|      1|            "msg.proto",
 2948|      1|            "// comment\n/* block */\nsyntax = \"proto3\";\n",
 2949|      1|        )?;
                       ^0
 2950|      1|        let (stats, _total_lines) =
 2951|      1|            count_c_style_lines(temp_dir.path().join("msg.proto").as_path())?;
                                                                                          ^0
 2952|      1|        assert_eq!(stats.code_lines, 1);
 2953|      1|        assert_eq!(stats.comment_lines, 2);
 2954|      1|        Ok(())
 2955|      1|    }
 2956|       |
 2957|       |    #[test]
 2958|      1|    fn test_cstyle_inline_block_comment() -> io::Result<()> {
 2959|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2960|      1|        create_test_file(
 2961|      1|            temp_dir.path(),
 2962|      1|            "x.c",
 2963|      1|            "int a; /* comment */ int b;\n/* start\n */ int c;\n",
 2964|      1|        )?;
                       ^0
 2965|      1|        let (stats, _total_lines) = count_c_style_lines(temp_dir.path().join("x.c").as_path())?;
                                                                                                            ^0
 2966|       |        // Expect 3 code lines: "int a;", "int b;" on first line, and "int c;" on third
 2967|      1|        assert!(stats.code_lines >= 3);
 2968|      1|        assert!(stats.comment_lines >= 2);
 2969|      1|        Ok(())
 2970|      1|    }
 2971|       |
 2972|       |    #[test]
 2973|      1|    fn test_cstyle_multiple_pairs_one_line() -> io::Result<()> {
 2974|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2975|      1|        create_test_file(
 2976|      1|            temp_dir.path(),
 2977|      1|            "y.c",
 2978|      1|            "int a; /* c1 */ mid /* c2 */ end;\n",
 2979|      1|        )?;
                       ^0
 2980|      1|        let (stats, _total_lines) = count_c_style_lines(temp_dir.path().join("y.c").as_path())?;
                                                                                                            ^0
 2981|      1|        assert!(stats.code_lines >= 3);
 2982|      1|        assert!(stats.comment_lines >= 2);
 2983|      1|        Ok(())
 2984|      1|    }
 2985|       |
 2986|       |    #[test]
 2987|      1|    fn test_cstyle_mixed_line_and_block_comments() -> io::Result<()> {
 2988|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 2989|      1|        create_test_file(
 2990|      1|            temp_dir.path(),
 2991|      1|            "mixed.c",
 2992|      1|            "int a = 0; // comment /* ignored */\nint b = 0; /* block */ // trailing\n",
 2993|      1|        )?;
                       ^0
 2994|      1|        let (stats, _total_lines) = count_c_style_lines(temp_dir.path().join("mixed.c").as_path())?;
                                                                                                                ^0
 2995|      1|        assert!(stats.code_lines >= 2);
 2996|      1|        assert!(stats.comment_lines >= 2);
 2997|      1|        Ok(())
 2998|      1|    }
 2999|       |
 3000|       |    #[test]
 3001|      1|    fn test_php_inline_block_comment() -> io::Result<()> {
 3002|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3003|      1|        create_test_file(
 3004|      1|            temp_dir.path(),
 3005|      1|            "x.php",
 3006|      1|            "<?php\n$y = 1; /* c */ $z = 2;\n?>\n",
 3007|      1|        )?;
                       ^0
 3008|      1|        let (stats, _total_lines) = count_php_lines(temp_dir.path().join("x.php").as_path())?;
                                                                                                          ^0
 3009|      1|        assert!(stats.code_lines >= 2);
 3010|      1|        assert!(stats.comment_lines >= 1);
 3011|      1|        Ok(())
 3012|      1|    }
 3013|       |
 3014|       |    #[test]
 3015|      1|    fn test_php_block_comment_followed_by_hash_comment() -> io::Result<()> {
 3016|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3017|      1|        create_test_file(
 3018|      1|            temp_dir.path(),
 3019|      1|            "y.php",
 3020|      1|            "<?php\n$foo = 1; /* block */ # trailing\n?>\n",
 3021|      1|        )?;
                       ^0
 3022|      1|        let (stats, _total_lines) = count_php_lines(temp_dir.path().join("y.php").as_path())?;
                                                                                                          ^0
 3023|      1|        assert!(stats.comment_lines >= 1); // block + hash comment
 3024|      1|        assert!(stats.code_lines >= 1);
 3025|      1|        Ok(())
 3026|      1|    }
 3027|       |
 3028|       |    #[test]
 3029|      1|    fn test_svg_xsl_line_counting() -> io::Result<()> {
 3030|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3031|      1|        create_test_file(temp_dir.path(), "pic.svg", "<svg><!-- c --><g/></svg>\n")?;
                                                                                                 ^0
 3032|      1|        create_test_file(
 3033|      1|            temp_dir.path(),
 3034|      1|            "sheet.xsl",
 3035|      1|            "<xsl:stylesheet><!-- c --></xsl:stylesheet>\n",
 3036|      1|        )?;
                       ^0
 3037|      1|        let (svg_stats, _) = count_xml_like_lines(temp_dir.path().join("pic.svg").as_path())?;
                                                                                                          ^0
 3038|      1|        let (xsl_stats, _) = count_xml_like_lines(temp_dir.path().join("sheet.xsl").as_path())?;
                                                                                                            ^0
 3039|      1|        assert!(svg_stats.code_lines >= 1 && svg_stats.comment_lines >= 1);
 3040|      1|        assert!(xsl_stats.code_lines >= 1 && xsl_stats.comment_lines >= 1);
 3041|      1|        Ok(())
 3042|      1|    }
 3043|       |
 3044|       |    #[test]
 3045|      1|    fn test_xml_multiple_pairs_one_line() -> io::Result<()> {
 3046|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3047|      1|        create_test_file(temp_dir.path(), "z.xml", "<a><!--c1--><b/><!--c2--></a>\n")?;
                                                                                                   ^0
 3048|      1|        let (stats, _total) = count_xml_like_lines(temp_dir.path().join("z.xml").as_path())?;
                                                                                                         ^0
 3049|      1|        assert!(stats.code_lines >= 1);
 3050|      1|        assert!(stats.comment_lines >= 2);
 3051|      1|        Ok(())
 3052|      1|    }
 3053|       |
 3054|       |    #[test]
 3055|      1|    fn test_max_depth_children_not_grandchildren() -> io::Result<()> {
 3056|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3057|      1|        let root = temp_dir.path();
 3058|      1|        let child = root.join("child");
 3059|      1|        let grand = child.join("grand");
 3060|      1|        fs::create_dir(&child)?;
                                            ^0
 3061|      1|        fs::create_dir(&grand)?;
                                            ^0
 3062|      1|        create_test_file(root, "a.rs", "fn main(){}\n")?;
                                                                     ^0
 3063|      1|        create_test_file(&child, "b.rs", "fn main(){}\n")?;
                                                                       ^0
 3064|      1|        create_test_file(&grand, "c.rs", "fn main(){}\n")?;
                                                                       ^0
 3065|       |
 3066|      1|        let args = Args {
 3067|      1|            max_depth: 1,
 3068|      1|            ..test_args()
 3069|      1|        };
 3070|      1|        let mut metrics = test_metrics();
 3071|      1|        let mut entries_count = 0usize;
 3072|      1|        let mut error_count = 0usize;
 3073|      1|        let stats = scan_directory(
 3074|      1|            root,
 3075|      1|            &args,
 3076|      1|            root,
 3077|      1|            &mut metrics,
 3078|      1|            0,
 3079|      1|            &mut entries_count,
 3080|      1|            &mut error_count,
 3081|      1|        )?;
                       ^0
 3082|       |        // Count Rust files aggregated across all dirs in stats
 3083|      1|        let mut rust_files = 0u64;
 3084|      2|        for dir in stats.values() {
                                 ^1
 3085|      2|            if let Some((n, _)) = dir.language_stats.get("Rust") {
 3086|      2|                rust_files += *n;
 3087|      2|            }
                          ^0
 3088|       |        }
 3089|      1|        assert_eq!(rust_files, 2); // root and child only
 3090|      1|        Ok(())
 3091|      1|    }
 3092|       |
 3093|       |    #[test]
 3094|      1|    fn test_filespec_filters_rs_only() -> io::Result<()> {
 3095|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3096|      1|        let root = temp_dir.path();
 3097|      1|        create_test_file(root, "a.rs", "fn main(){}\n")?;
                                                                     ^0
 3098|      1|        create_test_file(root, "b.py", "print('x')\n")?;
                                                                    ^0
 3099|      1|        let args = Args {
 3100|      1|            filespec: Some("*.rs".to_string()),
 3101|      1|            ..test_args()
 3102|      1|        };
 3103|      1|        let mut metrics = test_metrics();
 3104|      1|        let mut entries_count = 0usize;
 3105|      1|        let mut error_count = 0usize;
 3106|      1|        let stats = scan_directory(
 3107|      1|            root,
 3108|      1|            &args,
 3109|      1|            root,
 3110|      1|            &mut metrics,
 3111|      1|            0,
 3112|      1|            &mut entries_count,
 3113|      1|            &mut error_count,
 3114|      1|        )?;
                       ^0
 3115|       |        // Assert only Rust present
 3116|      1|        for dir in stats.values() {
 3117|      2|            for (lang, (n, _)) in &dir.language_stats {
                               ^1
 3118|      1|                assert_eq!(lang.as_str(), "Rust");
 3119|      1|                assert_eq!(*n, 1);
 3120|       |            }
 3121|       |        }
 3122|      1|        Ok(())
 3123|      1|    }
 3124|       |
 3125|       |    #[test]
 3126|      1|    fn test_filespec_recurses_into_nested_dirs() -> io::Result<()> {
 3127|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3128|      1|        let root = temp_dir.path();
 3129|      1|        let nested = root.join("nested").join("deep");
 3130|      1|        fs::create_dir_all(&nested)?;
                                                 ^0
 3131|      1|        create_test_file(root, "skip.py", "print('skip')\n")?;
                                                                          ^0
 3132|      1|        create_test_file(&nested, "find.rs", "fn nested() {}\n")?;
                                                                              ^0
 3133|      1|        create_test_file(&nested, "ignore.py", "print('ignore')\n")?;
                                                                                 ^0
 3134|       |
 3135|      1|        let args = Args {
 3136|      1|            filespec: Some("*.rs".to_string()),
 3137|      1|            ..test_args()
 3138|      1|        };
 3139|      1|        let mut metrics = test_metrics();
 3140|      1|        let mut entries_count = 0usize;
 3141|      1|        let mut error_count = 0usize;
 3142|      1|        let stats = scan_directory(
 3143|      1|            root,
 3144|      1|            &args,
 3145|      1|            root,
 3146|      1|            &mut metrics,
 3147|      1|            0,
 3148|      1|            &mut entries_count,
 3149|      1|            &mut error_count,
 3150|      1|        )?;
                       ^0
 3151|       |
 3152|      1|        let nested_canon = fs::canonicalize(&nested)?;
                                                                  ^0
 3153|      1|        let has_nested_stats = stats.contains_key(&nested_canon) || stats.contains_key(&nested);
                                                                                  ^0
 3154|      1|        assert!(has_nested_stats, "expected nested directory stats");
                                                ^0
 3155|       |
 3156|      1|        let rust_files: u64 = stats
 3157|      1|            .values()
 3158|      1|            .flat_map(|dir| dir.language_stats.get("Rust").map(|(n, _)| *n))
 3159|      1|            .sum();
 3160|      1|        assert_eq!(rust_files, 1);
 3161|      1|        Ok(())
 3162|      1|    }
 3163|       |
 3164|       |    #[test]
 3165|      1|    fn test_invalid_filespec_returns_error() -> io::Result<()> {
 3166|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3167|      1|        let root = temp_dir.path();
 3168|      1|        create_test_file(root, "a.rs", "fn main(){}\n")?;
                                                                     ^0
 3169|      1|        let args = Args {
 3170|      1|            filespec: Some("[".to_string()),
 3171|      1|            ..test_args()
 3172|      1|        };
 3173|      1|        let mut metrics = test_metrics();
 3174|      1|        let mut entries_count = 0usize;
 3175|      1|        let mut error_count = 0usize;
 3176|      1|        let err = scan_directory(
 3177|      1|            root,
 3178|      1|            &args,
 3179|      1|            root,
 3180|      1|            &mut metrics,
 3181|      1|            0,
 3182|      1|            &mut entries_count,
 3183|      1|            &mut error_count,
 3184|      1|        )
 3185|      1|        .expect_err("expected invalid filespec to return an error");
 3186|      1|        assert_eq!(err.kind(), io::ErrorKind::InvalidInput);
 3187|      1|        Ok(())
 3188|      1|    }
 3189|       |
 3190|       |    #[test]
 3191|      1|    fn test_skip_zero_stat_dcl_in_aggregation() -> io::Result<()> {
 3192|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3193|      1|        let root = temp_dir.path();
 3194|      1|        create_test_file(root, "not_dcl.com", "echo hi\n")?;
                                                                        ^0
 3195|      1|        create_test_file(root, "a.rs", "fn main(){}\n")?;
                                                                     ^0
 3196|      1|        let args = test_args();
 3197|      1|        let mut metrics = test_metrics();
 3198|      1|        let mut entries_count = 0usize;
 3199|      1|        let mut error_count = 0usize;
 3200|      1|        let stats = scan_directory(
 3201|      1|            root,
 3202|      1|            &args,
 3203|      1|            root,
 3204|      1|            &mut metrics,
 3205|      1|            0,
 3206|      1|            &mut entries_count,
 3207|      1|            &mut error_count,
 3208|      1|        )?;
                       ^0
 3209|      1|        let mut has_dcl = false;
 3210|      1|        for dir in stats.values() {
 3211|      1|            if dir.language_stats.contains_key("DCL") {
 3212|      0|                has_dcl = true;
 3213|      0|                break;
 3214|      1|            }
 3215|       |        }
 3216|      1|        assert!(!has_dcl);
 3217|      1|        Ok(())
 3218|      1|    }
 3219|       |
 3220|       |    #[test]
 3221|      1|    fn test_empty_file_counts_towards_totals() -> io::Result<()> {
 3222|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3223|      1|        let root = temp_dir.path();
 3224|      1|        create_test_file(root, "empty.rs", "")?;
                                                            ^0
 3225|      1|        let args = test_args();
 3226|      1|        let mut metrics = test_metrics();
 3227|      1|        let mut entries_count = 0usize;
 3228|      1|        let mut error_count = 0usize;
 3229|      1|        let stats = scan_directory(
 3230|      1|            root,
 3231|      1|            &args,
 3232|      1|            root,
 3233|      1|            &mut metrics,
 3234|      1|            0,
 3235|      1|            &mut entries_count,
 3236|      1|            &mut error_count,
 3237|      1|        )?;
                       ^0
 3238|      1|        let root_canon = fs::canonicalize(root)?;
                                                             ^0
 3239|      1|        let dir_stats = stats
 3240|      1|            .get(&root_canon)
 3241|      1|            .or_else(|| stats.get(root))
                                      ^0
 3242|      1|            .expect("expected root directory stats for empty file");
 3243|      1|        let (file_count, lang_stats) = dir_stats
 3244|      1|            .language_stats
 3245|      1|            .get("Rust")
 3246|      1|            .expect("expected Rust entry for empty file");
 3247|      1|        assert_eq!(*file_count, 1);
 3248|      1|        assert_eq!(lang_stats.code_lines, 0);
 3249|      1|        assert_eq!(lang_stats.comment_lines, 0);
 3250|      1|        assert_eq!(lang_stats.blank_lines, 0);
 3251|      1|        Ok(())
 3252|      1|    }
 3253|       |
 3254|       |    #[test]
 3255|      1|    fn test_mixed_code_and_comment_counts_once() -> io::Result<()> {
 3256|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3257|      1|        create_test_file(
 3258|      1|            temp_dir.path(),
 3259|      1|            "mixed.rs",
 3260|      1|            "fn main() { println!(\"hi\"); } // greet\n/* block */\n",
 3261|      1|        )?;
                       ^0
 3262|      1|        let (raw_stats, total_lines) =
 3263|      1|            count_lines_with_stats(temp_dir.path().join("mixed.rs").as_path())?;
                                                                                            ^0
 3264|      1|        let stats = normalize_stats(raw_stats, total_lines);
 3265|      1|        assert_eq!(total_lines, 2);
 3266|      1|        assert_eq!(
 3267|      1|            stats.code_lines + stats.comment_lines + stats.blank_lines,
 3268|      1|            total_lines
 3269|      1|        );
 3270|      1|        assert!(stats.code_lines >= 1);
 3271|      1|        Ok(())
 3272|      1|    }
 3273|       |
 3274|       |    #[test]
 3275|      1|    fn test_scan_directory_sums_match_metrics() -> io::Result<()> {
 3276|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3277|      1|        let root = temp_dir.path();
 3278|      1|        create_test_file(
 3279|      1|            root,
 3280|      1|            "mixed.rs",
 3281|      1|            "fn main() { println!(\"hi\"); } // greet\n/* block */\n",
 3282|      1|        )?;
                       ^0
 3283|      1|        create_test_file(root, "script.py", "print('hi')  # greet\n\n")?;
                                                                                     ^0
 3284|      1|        let args = test_args();
 3285|      1|        let mut metrics = test_metrics();
 3286|      1|        let mut entries_count = 0usize;
 3287|      1|        let mut error_count = 0usize;
 3288|      1|        let stats = scan_directory(
 3289|      1|            root,
 3290|      1|            &args,
 3291|      1|            root,
 3292|      1|            &mut metrics,
 3293|      1|            0,
 3294|      1|            &mut entries_count,
 3295|      1|            &mut error_count,
 3296|      1|        )?;
                       ^0
 3297|      1|        assert_eq!(error_count, 0);
 3298|      1|        let mut aggregated = LanguageStats::default();
 3299|      1|        for dir_stats in stats.values() {
 3300|      2|            for (_, lang_stats) in dir_stats.language_stats.values() {
                                                 ^1
 3301|      2|                aggregated.code_lines += lang_stats.code_lines;
 3302|      2|                aggregated.comment_lines += lang_stats.comment_lines;
 3303|      2|                aggregated.blank_lines += lang_stats.blank_lines;
 3304|      2|                aggregated.overlap_lines += lang_stats.overlap_lines;
 3305|      2|            }
 3306|       |        }
 3307|      1|        let sum = aggregated.code_lines + aggregated.comment_lines + aggregated.blank_lines
 3308|      1|            - aggregated.overlap_lines;
 3309|      1|        let lines_processed = metrics.lines_processed.load(Ordering::Relaxed);
 3310|      1|        assert_eq!(sum, lines_processed);
 3311|      1|        Ok(())
 3312|      1|    }
 3313|       |
 3314|       |    #[test]
 3315|      1|    fn test_algol_line_counting() -> io::Result<()> {
 3316|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3317|      1|        create_test_file(
 3318|      1|            temp_dir.path(),
 3319|      1|            "demo.alg",
 3320|      1|            "begin\nCOMMENT this is a comment;\nend\n",
 3321|      1|        )?;
                       ^0
 3322|      1|        let (stats, _total) = count_algol_lines(temp_dir.path().join("demo.alg").as_path())?;
                                                                                                         ^0
 3323|      1|        assert_eq!(stats.code_lines, 2); // begin/end
 3324|      1|        assert_eq!(stats.comment_lines, 1);
 3325|      1|        Ok(())
 3326|      1|    }
 3327|       |
 3328|       |    #[test]
 3329|      1|    fn test_algol_comment_variants() -> io::Result<()> {
 3330|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3331|      1|        create_test_file(
 3332|      1|            temp_dir.path(),
 3333|      1|            "variants.alg",
 3334|      1|            "COMMENT block without semicolon\nstill comment;\nco inline co\n# hash comment\nbegin\nend\n",
 3335|      1|        )?;
                       ^0
 3336|      1|        let (stats, _total) = count_algol_lines(temp_dir.path().join("variants.alg").as_path())?;
                                                                                                             ^0
 3337|      1|        assert!(stats.comment_lines >= 2);
 3338|      1|        assert!(stats.code_lines >= 2);
 3339|      1|        Ok(())
 3340|      1|    }
 3341|       |
 3342|       |    #[test]
 3343|      1|    fn test_cobol_line_counting() -> io::Result<()> {
 3344|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3345|      1|        create_test_file(
 3346|      1|            temp_dir.path(),
 3347|      1|            "prog.cob",
 3348|      1|            "       IDENTIFICATION DIVISION.\n      * comment in col 7\n       PROGRAM-ID. DEMO.\n       *> free comment\n",
 3349|      1|        )?;
                       ^0
 3350|      1|        let (stats, _total) = count_cobol_lines(temp_dir.path().join("prog.cob").as_path())?;
                                                                                                         ^0
 3351|      1|        assert_eq!(stats.comment_lines, 2);
 3352|      1|        assert!(stats.code_lines >= 2);
 3353|      1|        Ok(())
 3354|      1|    }
 3355|       |
 3356|       |    #[test]
 3357|      1|    fn test_fortran_line_counting() -> io::Result<()> {
 3358|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3359|      1|        create_test_file(
 3360|      1|            temp_dir.path(),
 3361|      1|            "m.f90",
 3362|      1|            "! comment\nprogram x\nprint *, 'hi'\nend\n",
 3363|      1|        )?;
                       ^0
 3364|      1|        let (stats, _total) = count_fortran_lines(temp_dir.path().join("m.f90").as_path())?;
                                                                                                        ^0
 3365|      1|        assert_eq!(stats.comment_lines, 1);
 3366|      1|        assert_eq!(stats.code_lines, 3);
 3367|      1|        Ok(())
 3368|      1|    }
 3369|       |
 3370|       |    #[test]
 3371|      1|    fn test_asm_line_counting() -> io::Result<()> {
 3372|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3373|      1|        create_test_file(temp_dir.path(), "x.asm", "; c\n# also c\nmov eax, eax\n")?;
                                                                                                 ^0
 3374|      1|        let (stats, _total) = count_asm_lines(temp_dir.path().join("x.asm").as_path())?;
                                                                                                    ^0
 3375|      1|        assert_eq!(stats.comment_lines, 2);
 3376|      1|        assert_eq!(stats.code_lines, 1);
 3377|      1|        Ok(())
 3378|      1|    }
 3379|       |
 3380|       |    #[test]
 3381|      1|    fn test_dcl_line_counting() -> io::Result<()> {
 3382|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3383|      1|        create_test_file(
 3384|      1|            temp_dir.path(),
 3385|      1|            "proc.com",
 3386|      1|            "$! comment\n$ write sys$output \"hi\"\n",
 3387|      1|        )?;
                       ^0
 3388|      1|        let (stats, _total) = count_dcl_lines(temp_dir.path().join("proc.com").as_path())?;
                                                                                                       ^0
 3389|      1|        assert_eq!(stats.comment_lines, 1);
 3390|      1|        assert_eq!(stats.code_lines, 1);
 3391|      1|        Ok(())
 3392|      1|    }
 3393|       |
 3394|       |    #[test]
 3395|      1|    fn test_dcl_non_dcl_com_file_sniff() -> io::Result<()> {
 3396|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3397|      1|        create_test_file(temp_dir.path(), "not_dcl.com", "echo hi\n")?;
                                                                                   ^0
 3398|      1|        let (stats, _total) = count_dcl_lines(temp_dir.path().join("not_dcl.com").as_path())?;
                                                                                                          ^0
 3399|      1|        assert_eq!(stats.code_lines, 0);
 3400|      1|        assert_eq!(stats.comment_lines, 0);
 3401|      1|        Ok(())
 3402|      1|    }
 3403|       |
 3404|       |    #[test]
 3405|      1|    fn test_dotfile_shell_detection() {
 3406|      1|        assert_eq!(get_language_from_extension(".bashrc"), Some("Shell"));
 3407|      1|        assert_eq!(get_language_from_extension(".zshrc"), Some("Shell"));
 3408|      1|    }
 3409|       |
 3410|       |    #[test]
 3411|      1|    fn test_row_formatting_is_ansi_safe() {
 3412|      1|        let line = format_language_stats_line(
 3413|      1|            "./dir",
 3414|      1|            "Rust",
 3415|      1|            12,
 3416|      1|            &LanguageStats {
 3417|      1|                code_lines: 34,
 3418|      1|                comment_lines: 5,
 3419|      1|                blank_lines: 6,
 3420|      1|                overlap_lines: 2,
 3421|      1|            },
 3422|      1|        );
 3423|      1|        // No ANSI escape
 3424|      1|        assert!(!line.contains('\u{1b}'));
 3425|       |        // Check widths (basic sanity)
 3426|       |        // prefix (<=40 left), space, lang (<=16), space, 8, space, 10, space, 10, space, 10, space, 10
 3427|       |        // Total minimum length should be >= 40+1+16+1+8+1+10+1+10+1+10+1+10 = 110
 3428|      1|        assert!(line.len() >= 110);
 3429|      1|    }
 3430|       |
 3431|       |    #[test]
 3432|      1|    fn test_max_entries_enforced() -> io::Result<()> {
 3433|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3434|      1|        let args = Args {
 3435|      1|            max_entries: 1,
 3436|      1|            ..test_args()
 3437|      1|        };
 3438|      1|        let mut metrics = test_metrics();
 3439|      1|        // Create two files
 3440|      1|        create_test_file(temp_dir.path(), "a.rs", "fn main(){}\n")?;
                                                                                ^0
 3441|      1|        create_test_file(temp_dir.path(), "b.rs", "fn main(){}\n")?;
                                                                                ^0
 3442|      1|        let mut entries_count = 0usize;
 3443|      1|        let mut error_count = 0usize;
 3444|      1|        let res = scan_directory(
 3445|      1|            temp_dir.path(),
 3446|      1|            &args,
 3447|      1|            temp_dir.path(),
 3448|      1|            &mut metrics,
 3449|      1|            0,
 3450|      1|            &mut entries_count,
 3451|      1|            &mut error_count,
 3452|      1|        );
 3453|      1|        assert!(res.is_err());
 3454|      1|        Ok(())
 3455|      1|    }
 3456|       |
 3457|       |    #[test]
 3458|      1|    fn test_iplan_line_counting() -> io::Result<()> {
 3459|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3460|      1|        create_test_file(temp_dir.path(), "calc.ipl", "/* c */\n! c\nSET X = 1\n")?;
                                                                                                ^0
 3461|      1|        let (stats, _total) = count_iplan_lines(temp_dir.path().join("calc.ipl").as_path())?;
                                                                                                         ^0
 3462|      1|        assert!(stats.comment_lines >= 2);
 3463|      1|        assert_eq!(stats.code_lines, 1);
 3464|      1|        Ok(())
 3465|      1|    }
 3466|       |
 3467|       |    #[test]
 3468|      1|    fn test_iplan_block_followed_by_bang_comment() -> io::Result<()> {
 3469|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3470|      1|        create_test_file(
 3471|      1|            temp_dir.path(),
 3472|      1|            "mix.ipl",
 3473|      1|            "SET X = 1 /* inline */ ! trailing\n/* block\ncontinues */ ! next\nVALUE\n",
 3474|      1|        )?;
                       ^0
 3475|      1|        let (stats, _total) = count_iplan_lines(temp_dir.path().join("mix.ipl").as_path())?;
                                                                                                        ^0
 3476|      1|        assert!(stats.code_lines >= 1);
 3477|      1|        assert!(stats.comment_lines >= 2);
 3478|      1|        Ok(())
 3479|      1|    }
 3480|       |
 3481|       |    #[test]
 3482|      1|    fn test_scala_is_c_style() -> io::Result<()> {
 3483|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3484|      1|        create_test_file(
 3485|      1|            temp_dir.path(),
 3486|      1|            "Main.scala",
 3487|      1|            "object Main {\n// comment\n/* block */\nval x = 1\n}\n",
 3488|      1|        )?;
                       ^0
 3489|      1|        let (stats, _total_lines) = count_c_style_lines(&temp_dir.path().join("Main.scala"))?;
                                                                                                          ^0
 3490|      1|        assert_eq!(stats.code_lines, 3);
 3491|      1|        assert_eq!(stats.comment_lines, 2);
 3492|      1|        Ok(())
 3493|      1|    }
 3494|       |
 3495|       |    // Additional hardening tests
 3496|       |
 3497|       |    #[test]
 3498|      1|    fn test_cobol_short_line_and_leading_spaces() -> io::Result<()> {
 3499|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3500|       |        // Short line (<7 chars) should not be treated as comment
 3501|      1|        create_test_file(temp_dir.path(), "short.cob", "*\n")?;
                                                                           ^0
 3502|      1|        let (stats1, _) = count_cobol_lines(temp_dir.path().join("short.cob").as_path())?;
                                                                                                      ^0
 3503|      1|        assert_eq!(stats1.code_lines, 1);
 3504|       |        // Leading spaces then '*' in column 1 is code (not fixed-form comment)
 3505|      1|        create_test_file(temp_dir.path(), "lead.cob", "   * TEXT\n")?;
                                                                                  ^0
 3506|      1|        let (stats2, _) = count_cobol_lines(temp_dir.path().join("lead.cob").as_path())?;
                                                                                                     ^0
 3507|      1|        assert_eq!(stats2.code_lines, 1);
 3508|      1|        Ok(())
 3509|      1|    }
 3510|       |
 3511|       |    #[test]
 3512|      1|    fn test_fortran_fixed_vs_free_form() -> io::Result<()> {
 3513|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3514|       |        // Fixed-form comment indicator in col 1
 3515|      1|        create_test_file(temp_dir.path(), "f1.f", "C comment\n")?;
                                                                              ^0
 3516|      1|        let (s1, _) = count_fortran_lines(temp_dir.path().join("f1.f").as_path())?;
                                                                                               ^0
 3517|      1|        assert_eq!(s1.comment_lines, 1);
 3518|       |        // Leading space then 'C' is code (free form)
 3519|      1|        create_test_file(temp_dir.path(), "f2.f", " C not comment\n")?;
                                                                                   ^0
 3520|      1|        let (s2, _) = count_fortran_lines(temp_dir.path().join("f2.f").as_path())?;
                                                                                               ^0
 3521|      1|        assert_eq!(s2.code_lines, 1);
 3522|       |        // Inline '!' split
 3523|      1|        create_test_file(temp_dir.path(), "f3.f90", "print *, 'x' ! trailing\n")?;
                                                                                              ^0
 3524|      1|        let (s3, _) = count_fortran_lines(temp_dir.path().join("f3.f90").as_path())?;
                                                                                                 ^0
 3525|      1|        assert_eq!(s3.code_lines, 1);
 3526|      1|        assert_eq!(s3.comment_lines, 1);
 3527|      1|        Ok(())
 3528|      1|    }
 3529|       |
 3530|       |    #[test]
 3531|      1|    fn test_hcl_multiple_pairs_inline() -> io::Result<()> {
 3532|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3533|      1|        create_test_file(temp_dir.path(), "x.tf", "a=1 /*c*/ b=2 /*d*/ c=3\n")?;
                                                                                            ^0
 3534|      1|        let (stats, _) = count_hcl_lines(temp_dir.path().join("x.tf").as_path())?;
                                                                                              ^0
 3535|      1|        assert!(stats.code_lines >= 3);
 3536|      1|        assert!(stats.comment_lines >= 2);
 3537|      1|        Ok(())
 3538|      1|    }
 3539|       |
 3540|       |    #[test]
 3541|      1|    fn test_powershell_inline_and_multiblock() -> io::Result<()> {
 3542|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3543|      1|        create_test_file(
 3544|      1|            temp_dir.path(),
 3545|      1|            "ps.ps1",
 3546|      1|            "Write-Host 'a' <# c #> 'b' <# d #> 'c'\n",
 3547|      1|        )?;
                       ^0
 3548|      1|        let (s1, _) = count_powershell_lines(temp_dir.path().join("ps.ps1").as_path())?;
                                                                                                    ^0
 3549|      1|        assert!(s1.code_lines >= 3);
 3550|      1|        assert!(s1.comment_lines >= 2);
 3551|      1|        create_test_file(
 3552|      1|            temp_dir.path(),
 3553|      1|            "ps2.ps1",
 3554|      1|            "Write-Host 'x'\n<#\nblock\n#> Write-Host 'y'\n",
 3555|      1|        )?;
                       ^0
 3556|      1|        let (s2, _) = count_powershell_lines(temp_dir.path().join("ps2.ps1").as_path())?;
                                                                                                     ^0
 3557|      1|        assert!(s2.code_lines >= 2);
 3558|      1|        assert!(s2.comment_lines >= 2);
 3559|      1|        Ok(())
 3560|      1|    }
 3561|       |
 3562|       |    #[test]
 3563|      1|    fn test_pascal_mixed_nested_blocks() -> io::Result<()> {
 3564|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3565|      1|        create_test_file(
 3566|      1|            temp_dir.path(),
 3567|      1|            "p.pas",
 3568|      1|            "{c1} (*c2*) code\n(* multi\nline *) code2\n",
 3569|      1|        )?;
                       ^0
 3570|      1|        let (stats, _) = count_pascal_lines(temp_dir.path().join("p.pas").as_path())?;
                                                                                                  ^0
 3571|      1|        assert!(stats.comment_lines >= 2);
 3572|      1|        assert!(stats.code_lines >= 2);
 3573|      1|        Ok(())
 3574|      1|    }
 3575|       |
 3576|       |    #[test]
 3577|      1|    fn test_perl_pod_block() -> io::Result<()> {
 3578|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3579|      1|        create_test_file(
 3580|      1|            temp_dir.path(),
 3581|      1|            "p.pl",
 3582|      1|            "print 'x';\n=pod\nthis is pod\n=cut\nprint 'y';\n",
 3583|      1|        )?;
                       ^0
 3584|      1|        let (stats, _) = count_perl_lines(temp_dir.path().join("p.pl").as_path())?;
                                                                                               ^0
 3585|      1|        assert!(stats.comment_lines >= 2);
 3586|      1|        assert_eq!(stats.code_lines, 2);
 3587|      1|        Ok(())
 3588|      1|    }
 3589|       |
 3590|       |    #[test]
 3591|      1|    fn test_inline_hash_is_code_for_hash_langs() -> io::Result<()> {
 3592|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3593|      1|        create_test_file(temp_dir.path(), "a.yaml", "key: 1 # inline\n")?;
                                                                                      ^0
 3594|      1|        let (yml, _) = count_yaml_lines(temp_dir.path().join("a.yaml").as_path())?;
                                                                                               ^0
 3595|      1|        assert_eq!(yml.code_lines, 1);
 3596|      1|        create_test_file(temp_dir.path(), "a.toml", "name='x' # inline\n")?;
                                                                                        ^0
 3597|      1|        let (toml, _) = count_toml_lines(temp_dir.path().join("a.toml").as_path())?;
                                                                                                ^0
 3598|      1|        assert_eq!(toml.code_lines, 1);
 3599|      1|        create_test_file(temp_dir.path(), "a.ini", "name=value ; inline\n")?;
                                                                                         ^0
 3600|      1|        let (ini, _) = count_ini_lines(temp_dir.path().join("a.ini").as_path())?;
                                                                                             ^0
 3601|      1|        assert_eq!(ini.code_lines, 1);
 3602|      1|        create_test_file(temp_dir.path(), "CMakeLists.txt", "set(X 1) # inline\n")?;
                                                                                                ^0
 3603|      1|        let (cmake, _) = count_cmake_lines(temp_dir.path().join("CMakeLists.txt").as_path())?;
                                                                                                          ^0
 3604|      1|        assert_eq!(cmake.code_lines, 1);
 3605|      1|        create_test_file(temp_dir.path(), "Makefile", "VAR=1 # inline\n")?;
                                                                                       ^0
 3606|      1|        let (mk, _) = count_makefile_lines(temp_dir.path().join("Makefile").as_path())?;
                                                                                                    ^0
 3607|      1|        assert_eq!(mk.code_lines, 1);
 3608|      1|        Ok(())
 3609|      1|    }
 3610|       |
 3611|       |    #[test]
 3612|      1|    fn test_non_recursive_root_only() -> io::Result<()> {
 3613|      1|        let temp_dir = TempDir::new()?;
                                                   ^0
 3614|      1|        let root = temp_dir.path();
 3615|      1|        let child = root.join("child");
 3616|      1|        fs::create_dir(&child)?;
                                            ^0
 3617|      1|        create_test_file(root, "a.rs", "fn main(){}\n")?;
                                                                     ^0
 3618|      1|        create_test_file(&child, "b.rs", "fn main(){}\n")?;
                                                                       ^0
 3619|      1|        let args = Args {
 3620|      1|            non_recursive: true,
 3621|      1|            ..test_args()
 3622|      1|        };
 3623|      1|        let mut metrics = test_metrics();
 3624|      1|        let mut entries_count = 0usize;
 3625|      1|        let mut error_count = 0usize;
 3626|      1|        let stats = scan_directory(
 3627|      1|            root,
 3628|      1|            &args,
 3629|      1|            root,
 3630|      1|            &mut metrics,
 3631|      1|            0,
 3632|      1|            &mut entries_count,
 3633|      1|            &mut error_count,
 3634|      1|        )?;
                       ^0
 3635|       |        // Ensure only one Rust file counted
 3636|      1|        let mut rust_files = 0u64;
 3637|      1|        for dir in stats.values() {
 3638|      1|            if let Some((n, _)) = dir.language_stats.get("Rust") {
 3639|      1|                rust_files += *n;
 3640|      1|            }
                          ^0
 3641|       |        }
 3642|      1|        assert_eq!(rust_files, 1);
 3643|      1|        Ok(())
 3644|      1|    }
 3645|       |}