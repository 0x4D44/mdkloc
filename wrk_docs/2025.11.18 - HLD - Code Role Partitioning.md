# Code Role Partitioning – High Level Design
*Date:* 2025-11-18
*Author:* Codex (mdkloc)

## 1. Problem Statement & Context
mdkloc v2.0.0 reports code, comment, mixed, and blank totals per language and aggregates these numbers up the directory tree. All code is treated uniformly, which prevents downstream consumers from distinguishing production logic from tests. The team wants to introduce a *code role* dimension (mainline vs. test), starting with Rust (where intra-file test modules are common) while ensuring the framework can expand to other languages as heuristics mature. The default path must remain backward compatible: if no role-specific heuristics run, every counted line should fall into the existing “mainline” totals.

## 2. Goals
1. Provide an extendable mechanism to assign counted lines to a `CodeRole` (at minimum `Mainline` and `Test`).
2. Keep the pre-existing CLI experience unchanged unless a user explicitly asks for the role view.
3. Support both file-level and intra-file test detection so Rust `#[cfg(test)]`/`mod tests` do not inflate mainline totals.
4. Maintain existing performance characteristics (single pass over each file; no extra allocations in the hot path).
5. Preserve deterministic behavior for existing integration tests; new tests should cover the role-aware output.

## 3. Non-Goals
- Automatically identifying other categories (e.g., generated code, benchmarks) in this iteration.
- Perfect classification for every language; only Rust will have intra-file awareness initially.
- Surfacing role metrics in the summary banner unless a new flag opts in.
- Changing the command-line surface (flags/options) for unrelated features.

## 4. Terminology
- **CodeRole**: enum representing the semantic role of a counted line. Initial variants: `Mainline` (default) and `Test`.
- **LanguageStats**: existing struct capturing `code/comment/blank/overlap` counts for a slice of source.
- **RoleStats**: aggregation of `LanguageStats` and file counts for a specific `CodeRole`.
- **RoleSplit**: per-file result produced by the counting pipeline that includes all roles populated by that parser.

## 5. Current Architecture Snapshot
1. `count_lines_with_stats(path)` → `(LanguageStats, total_lines)` using language-specific parsers.
2. `process_file()` normalizes the stats, updates `DirectoryStats.language_stats: HashMap<String, (u64, LanguageStats)>` and increments performance counters.
3. Reporting (`build_analysis_report`) iterates the directory map and prints one row per language with totals derived from the stored `LanguageStats`.
4. CLI integration tests exercise this surface, asserting exact table contents.

Introducing role awareness impacts each of the above steps.

## 6. Proposed Solution
### 6.1 High-Level Flow
1. Determine a `FileRoleHint` before counting (based on file path/name). This is useful for languages like Go/JS/Python where entire files are often dedicated to tests.
2. Invoke a role-aware counting function returning `RoleSplit` instead of a flat `LanguageStats`. Parsers that are not role aware simply funnel all numbers into the `Mainline` bucket.
3. Normalize each role bucket individually (to keep `code + comment + blank == total_lines` per role) and also maintain a combined view for backward compatibility.
4. Aggregate into directory totals keyed by `(language, role)` while maintaining helper methods that return a flattened sum for legacy consumers.
5. Extend reporting to optionally expose role-specific rows/columns under a new CLI flag (e.g., `--role-breakdown`). Without the flag the totals remain identical to v2.0.0, ensuring CLI tests continue to pass until updated fixtures are introduced.

### 6.2 Data Model Changes
```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
enum CodeRole { Mainline, Test }

#[derive(Debug, Default, Clone, Copy)]
struct RoleStats {
    files: u64,
    totals: LanguageStats,
}

#[derive(Debug, Default, Clone)]
struct LanguageEntry {
    per_role: HashMap<CodeRole, RoleStats>,
}

#[derive(Debug, Default)]
struct DirectoryStats {
    language_stats: HashMap<String, LanguageEntry>,
}
```
- `RoleStats::merge(&mut self, other: &RoleStats)` increments file counts and per-field totals.
- Helper: `LanguageEntry::flatten()` returns a `RoleStats` view representing `Mainline + Test` for callers that do not care about roles.
- `LanguageStats` remains unchanged (other than new helper methods). We reuse `normalize_stats` per role.

### 6.3 Counting API Changes
```rust
struct RoleSplit {
    buckets: HashMap<CodeRole, LanguageStats>,
    total_lines: u64,
}

fn count_lines_with_roles(path: &Path, role_hint: FileRoleHint) -> io::Result<RoleSplit>;
```
- Default implementation wraps the existing `count_lines_with_stats` and writes everything into `CodeRole::Mainline`.
- Language-specific parsers (e.g., Rust) may ignore `role_hint` and rely on intra-file detection.
- `FileRoleHint` enumerates `Unknown`, `TestFile`, `MainlineOnly`. Path heuristics (`*_test.rs`, `/tests/`, `__tests__/`) set this ahead of counting.

### 6.4 Rust Intra-File Detection
- Introduce a lightweight state machine inside `count_rust_lines_role_aware`:
  - Track `in_test_cfg`: set when encountering `#[cfg(test)]` (with optional attributes stack depth) until the next item boundary (`fn`, `mod`, `impl`).
  - Track `in_test_module`: enter when parsing `mod tests` where the module body either follows inline `{ ... }` or in a separate file; only apply when decorated with `#[cfg(test)]` to avoid false positives.
  - Track `in_test_fn`: triggered by `#[test]` attribute; only the associated function body counts as test code.
  - For each logical line we decide `(role, classification)` before incrementing stats. Comments and blanks inside test scopes should count toward the `Test` role.
- Fallback: if the parser encounters constructs it cannot confidently classify, it should default to `Mainline` to avoid under-reporting production code.

### 6.5 File-Level Heuristics for Other Languages
- Provide a shared function `infer_role_from_path(path: &Path) -> FileRoleHint` covering:
  - Rust integration tests: `tests/**/*.rs` → `TestFile`.
  - Go: `*_test.go` → `TestFile` (future extension).
  - JS/TS: `*.test.tsx`, `*.spec.js`, directories named `__tests__`.
  - Python: files starting with `test_` or under `tests/`.
- For this iteration, only the Rust integration-test case is wired up; others remain TODO but the API contracts support them.

### 6.6 Aggregation Logic
1. `process_file` obtains `RoleSplit` and iterates each `(role, stats)` pair:
   - Normalize stats with the known `total_lines` (per role) to keep overlap tracking intact.
   - Retrieve `LanguageEntry` via `DirectoryStats.language_stats.entry(language)`.
   - Update `RoleStats` for the matching role (increment `files` once per role that received non-zero totals).
2. Grand totals are computed by summing across `(language, role)` pairs. Helper `collect_grand_totals(role_filter)` returns either combined totals or role-specific ones.

### 6.7 Reporting / CLI Surface
- **Default behavior:** The current table remains unchanged by summing both roles before rendering. File counts stay the total number of files that produced any stats (even if only `Test`).
- **New flag (`--role-breakdown`):**
  - Adds two additional tables:
    1. `Mainline only` (mirrors current format but excludes test data).
    2. `Test only` (same columns, showing zero rows when absent).
  - Optionally add inline annotations in the language rows, e.g., `Rust (test)` to avoid exploding the width.
- `readme.md` gains a “Role breakdown” subsection showing sample output and describing the flag.
- CLI integration tests: augment `tests/cli_totals*.rs` with new fixtures gated by the flag to avoid rewriting every golden file.

### 6.8 Configuration Hooks
- Later iterations can add `--include-role=<role>` filters or environment variables, but for this HLD we scope to a single boolean flag.
- Expose a library-level opt-in so other crates embedding mdkloc can request role splits without parsing CLI args.

### 6.9 Performance & Memory Considerations
- The additional maps are tiny (two roles × languages). We can store `RoleStats` in an array `[RoleStats; 2]` indexed by `CodeRole as usize` to avoid hash overhead; the HashMap version keeps the API generic but we should benchmark before landing.
- Rust parser work adds a few booleans and string scans per line; expected overhead is <3% for large files. Profiling will confirm.
- No extra file system traversals are introduced.

### 6.10 Error Handling & Observability
- If a parser fails to classify roles, log in verbose mode: `verbose` users see `Role inference defaulted to mainline for <file>`.
- Counters for “files with role overrides” help validate coverage in metrics output (e.g., add to `PerformanceMetrics`).

## 7. Testing Strategy
1. **Unit Tests**
   - New tests for `infer_role_from_path` covering Rust `tests/` fixtures and negative cases.
   - Parser-level tests inside `tests_included.rs` verifying that `#[cfg(test)]` modules update the `Test` bucket while production code remains untouched.
   - Serialization helpers for `RoleSplit` and normalization routines.
2. **Integration Tests**
   - Extend an existing CLI test (e.g., `cli_totals.rs`) with the `--role-breakdown` flag and update the golden output to include the new tables.
   - Add a dedicated fixture focusing on Rust projects with both inline and directory-based tests.
3. **Regression**
   - Re-run the entire suite without the flag to ensure no diffs occur in outputs (guarding backwards compatibility).
   - Add a coverage expectation that at least one role-aware path executes (e.g., run mdkloc on `src/` to hit `#[cfg(test)]`).

## 8. Rollout Plan
1. Implement the data-model refactor and ensure default output remains identical (verified via snapshot tests).
2. Wire in Rust parser role detection and path-based hints for files under `tests/`.
3. Introduce the CLI flag + documentation + integration fixtures.
4. Monitor performance and classification accuracy; iterate on heuristics before expanding to other languages.

## 9. Risks & Mitigations
- **Scope creep:** Role detection per language can balloon; the phased flag ensures we can merge the framework before supporting every language.
- **False positives:** Misclassifying production lines as tests would undercount mainline totals. Mitigate by defaulting to `Mainline` unless the parser is certain.
- **Output churn:** Any change to the core table risks breaking downstream scripts. Keeping the default view untouched limits this risk.
- **Maintenance overhead:** Role-aware parsing complicates already-long functions. Consider extracting Rust parsing into a dedicated module with more readable state machines.

## 10. Open Questions / Follow-Ups
1. Should directory totals also expose test/mainline splits, or only language totals?
2. Do we need a machine-readable output (JSON) to help CI pipelines consume role data without parsing the table?
3. Should `PerformanceMetrics` report separate rates for test vs. mainline to aid observability?
4. For languages with doc-tests (Rust) or inline doctest fences (Python), do we treat them as tests, comments, or code?

---
This HLD sets up the scaffolding for role-aware counting while keeping existing behavior stable. Subsequent tasks will focus on detailed parser changes, CLI UX, and comprehensive tests.
